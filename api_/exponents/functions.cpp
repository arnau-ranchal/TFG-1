//
// Created by TESTER on 03/11/2023.
//

#ifndef TFG_FUNCTIONS_H
#define TFG_FUNCTIONS_H

#include <complex>
#include <cmath>
#include <iostream>
#include <vector>
#include <iomanip>
#include <algorithm>
#include "functions.h"
#include <Eigen/Dense>
#include <chrono>
#include <unsupported/Eigen/MatrixFunctions>
#include <unordered_map>
#include <limits>

using namespace std;
using namespace Eigen;

#define DEBUG true

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define PI M_PI
#define eu std::exp(1.0)
const complex<double> I(0.0, 1.0);
#define vms vector<chrono::microseconds>

double SNR = 1; // positive
// vector<complex<double>> X = {1,1,1,1};
// vector<complex<double>> X = {1,2};
int sizeX = pow(2, 6);
vector<double> Qq;

vector<complex<double>> X;
//vector<complex<double>> X;
// complex<double> I1 (0,2 * PI * 1 / 4), I2 (0,2 * PI * 2 / 4), I3 (0,2 * PI * 3 / 4);
// vector<complex<double>> X = {1,exp(I1), exp(I2), exp(I3)};
/* vector<complex<double>> X = {complex<double> (-1/sqrt(2),-1/sqrt(2) ),
                             complex<double> ( 1/sqrt(2),-1/sqrt(2) ),
                             complex<double> (-1/sqrt(2), 1/sqrt(2) ),
                             complex<double> ( 1/sqrt(2), 1/sqrt(2) )   };*/

double R;
unordered_map<int, vector<double>> all_hweights;
unordered_map<int, vector<double>> all_roots;
unordered_map<int, vector<double>> all_multhweights;

int n = 15; // todo: warning: temporary
void setN(int n_) { n = n_; }

// -- MATRIX DEFINITIONS --
VectorXd Q_mat;
MatrixXd PI_mat;
MatrixXd W_mat;
VectorXcd X_mat(sizeX);
MatrixXd D_mat;
VectorXd A_mat; // alphas

double low = n; // todo: warning: temporary: before was 17.0

vms e0_times;// = {std::chrono::microseconds(1), std::chrono::microseconds(2), std::chrono::microseconds(3)};
vms NAG_cc_times;
vms NAG_iid_times;
vms NAG_times;
vms GD_cc_times;
vms NAG_co_times;
vms GD_iid_times;
vms GD_co_times;
vms GD_ccomp_times;
vms gradient_e0_co_times;
vms fa_times;
vms gradient_f_times;
vms gradient_f_co_times;
vms fa_co_times;
vms e02_times;
vms E_0_co_times;
vms gradient_e0_times;
vms compute_hweights_times;
vms mult_newhweights_times;


unordered_map<string, vector<chrono::microseconds>> get_times() {
    return
            {{"e0_times",               e0_times},// = {std::chrono::microseconds(1), std::chrono::microseconds(2), std::chrono::microseconds(3)};{NAG_cc_times, "NAG_cc_times",
             {"NAG_iid_times",          NAG_iid_times},
             {"NAG_times",              NAG_times},
             {"GD_cc_times",            GD_cc_times},
             {"NAG_co_times",           NAG_co_times},
             {"GD_iid_times",           GD_iid_times},
             {"GD_co_times",            GD_co_times},
             {"GD_ccomp_times",         GD_ccomp_times},
             {"gradient_e0_co_times",   gradient_e0_co_times},
             {"fa_times",               fa_times},
             {"gradient_f_times",       gradient_f_times},
             {"gradient_f_co_times",    gradient_f_co_times},
             {"fa_co_times",            fa_co_times},
             {"e02_times",              e02_times},
             {"E_0_co_times",           E_0_co_times},
             {"gradient_e0_times",      gradient_e0_times},
             {"compute_hweights_times", compute_hweights_times},
             {"mult_newhweights_times", mult_newhweights_times}};
}

double abs_sq(std::complex<double> a) { return pow(real(a), 2) + pow(imag(a), 2); }

vector<double> getAllHweights() {
    return all_hweights[n];
}

vector<double> getAllRoots() {
    return all_roots[n];
}

vector<double> getAllMultHweights() {
    return all_multhweights[n];
}


unsigned long long factorial(unsigned int n) {
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

vector<double>
Hroots(int n) { // returns the roots of the Hermite polynomial of degree n up to n = 40 with 16 digits of precision
    vector<double> roots;
    switch (n) { // very small n should not be used to approximate correctly
        case (1):
            return {0};
        case (2):
            return {-0.7071067811865475, 0.7071067811865475};
        case (3):
            return {-1.224744871391589, 0, 1.224744871391589};
        case (4):
            return {-1.650680123885785, -0.5246476232752904, 0.5246476232752904, 1.650680123885785};
        case (5):
            return {-2.020182870456086, -0.9585724646138185, 0, 0.9585724646138185, 2.020182870456086};
        case (6):
            return {-2.350604973674492, -1.3358490740136968, -0.4360774119276165, 0.4360774119276165,
                    1.3358490740136968, 2.350604973674492};
        case (7):
            return {-2.651961356835233, -1.673551628767471, -0.8162878828589647, 0, 0.8162878828589647,
                    1.673551628767471, 2.651961356835233};
        case (8):
            return {-2.930637420257244, -1.981656756695843, -1.1571937124467802, -0.3811869902073221,
                    0.3811869902073221, 1.1571937124467802, 1.981656756695843, 2.930637420257244};
        case (9):
            return {-3.190993201781528, -2.266580584531843, -1.468553289216668, -0.7235510187528376, 0,
                    0.7235510187528376, 1.468553289216668, 2.266580584531843, 3.190993201781528};
        case (10):
            return {-3.436159118837738, -2.53273167423279, -1.756683649299882, -1.036610829789514, -0.3429013272237046,
                    0.3429013272237046, 1.036610829789514, 1.756683649299882, 2.53273167423279, 3.436159118837738};
        case (11):
            return {-3.668470846559583, -2.783290099781652, -2.025948015825755, -1.326557084494933, -0.6568095668820998,
                    0, 0.6568095668820998, 1.326557084494933, 2.025948015825755, 2.783290099781652, 3.668470846559583};
        case (12):
            return {-3.889724897869782, -3.02063702512089, -2.27950708050106, -1.597682635152605, -0.9477883912401637,
                    -0.3142403762543591, 0.3142403762543591, 0.9477883912401637, 1.597682635152605, 2.27950708050106,
                    3.02063702512089, 3.889724897869782};
        case (13):
            return {-4.10133759617864, -3.24660897837241, -2.519735685678238, -1.853107651601512, -1.220055036590748,
                    -0.6057638791710601, 0, 0.6057638791710601, 1.220055036590748, 1.853107651601512, 2.519735685678238,
                    3.24660897837241, 4.10133759617864};
        case (14):
            return {-4.304448570473632, -3.462656933602271, -2.748470724985403, -2.095183258507717, -1.476682731141141,
                    -0.8787137873293994, -0.2917455106725621, 0.2917455106725621, 0.8787137873293994, 1.476682731141141,
                    2.095183258507717, 2.748470724985403, 3.462656933602271, 4.304448570473632};
        case (15):
            return {-4.499990707309392, -3.669950373404453, -2.967166927905603, -2.325732486173858, -1.719992575186489,
                    -1.136115585210921, -0.5650695832555757, 0, 0.5650695832555757, 1.136115585210921,
                    1.719992575186489, 2.325732486173858, 2.967166927905603, 3.669950373404453, 4.499990707309392};
        case (16):
            return {-4.688738939305818, -3.869447904860123, -3.176999161979956, -2.546202157847481, -1.951787990916254,
                    -1.380258539198881, -0.8229514491446559, -0.2734810461381525, 0.2734810461381525,
                    0.8229514491446559, 1.380258539198881, 1.951787990916254, 2.546202157847481, 3.176999161979956,
                    3.869447904860123, 4.688738939305818};
        case (17):
            return {-4.871345193674403, -4.061946675875474, -3.378932091141494, -2.757762915703889, -2.173502826666621,
                    -1.612924314221231, -1.067648725743451, -0.5316330013426547, 0, 0.5316330013426547,
                    1.067648725743451, 1.612924314221231, 2.173502826666621, 2.757762915703889, 3.378932091141494,
                    4.061946675875474, 4.871345193674403};
        case (18):
            return {-5.048364008874467, -4.248117873568126, -3.573769068486266, -2.961377505531607, -2.386299089166686,
                    -1.835531604261629, -1.300920858389617, -0.7766829192674117, -0.2582677505190968,
                    0.2582677505190968, 0.7766829192674117, 1.300920858389617, 1.835531604261629, 2.386299089166686,
                    2.961377505531607, 3.573769068486266, 4.248117873568126, 5.048364008874467};
        case (19):
            return {-5.220271690537482, -4.428532806603779, -3.76218735196402, -3.157848818347602, -2.591133789794543,
                    -2.049231709850619, -1.524170619393533, -1.010368387134311, -0.5035201634238882, 0,
                    0.5035201634238882, 1.010368387134311, 1.524170619393533, 2.049231709850619, 2.591133789794543,
                    3.157848818347602, 3.76218735196402, 4.428532806603779, 5.220271690537482};
        case (20):
            return {-5.387480890011233, -4.603682449550744, -3.944764040115625, -3.347854567383216, -2.78880605842813,
                    -2.254974002089276, -1.738537712116586, -1.234076215395323, -0.7374737285453944,
                    -0.2453407083009012, 0.2453407083009012, 0.7374737285453944, 1.234076215395323, 1.7385377121165861,
                    2.254974002089276, 2.78880605842813, 3.347854567383216, 3.944764040115625, 4.603682449550744,
                    5.387480890011233};
        case (21):
            return {-5.550351873264678, -4.773992343411219, -4.12199554749184, -3.531972877137678, -2.979991207704598,
                    -2.453552124512838, -1.944962949186254, -1.448934250650732, -0.961499634418369, -0.4794507070791076,
                    0, 0.4794507070791076, 0.961499634418369, 1.448934250650732, 1.944962949186254, 2.453552124512838,
                    2.979991207704598, 3.531972877137678, 4.12199554749184, 4.773992343411219, 5.550351873264678};
        case (22):
            return {-5.709201353205264, -4.939834131060176, -4.294312480593162, -3.710701532877805, -3.165265909202137,
                    -2.645637441058173, -2.144233592798534, -1.655874373286422, -1.176713958481244, -0.7036860971700069,
                    -0.2341791399309906, 0.2341791399309906, 0.7036860971700069, 1.176713958481244, 1.655874373286422,
                    2.144233592798534, 2.645637441058173, 3.165265909202137, 3.710701532877805, 4.294312480593162,
                    4.939834131060176, 5.709201353205264};
        case (23):
            return {-5.864309498984573, -5.101534610476677, -4.462091173740007, -3.884472708106102, -3.345127159941225,
                    -2.831803787126157, -2.337016211474456, -1.855677037671371, -1.384039585682495, -0.9191514654425638,
                    -0.4585383500681048, 0, 0.4585383500681048, 0.9191514654425638, 1.384039585682495,
                    1.855677037671371, 2.337016211474456, 2.831803787126157, 3.345127159941225, 3.884472708106102,
                    4.462091173740007, 5.101534610476677, 5.864309498984573};
        case (24):
            return {-6.01592556142574, -5.259382927668044, -4.625662756423787, -4.05366440244815, -3.520006813034525,
                    -3.012546137565565, -2.523881017011427, -2.049003573661699, -1.584250010961694, -1.126760817611245,
                    -0.6741711070372122, -0.2244145474725156, 0.2244145474725156, 0.6741711070372122, 1.126760817611245,
                    1.584250010961694, 2.049003573661699, 2.523881017011427, 3.012546137565565, 3.520006813034525,
                    4.05366440244815, 4.625662756423787, 5.259382927668044, 6.01592556142574};
        case (25):
            return {-6.164272434052452, -5.413636355280034, -4.785320367352224, -4.218609444386561, -3.690282876998356,
                    -3.188294924425105, -2.705320237173026, -2.236420130267281, -1.778001124337147, -1.327280702073084,
                    -0.8819827562138214, -0.4401472986453083, 0, 0.4401472986453083, 0.8819827562138214,
                    1.327280702073084, 1.778001124337147, 2.236420130267281, 2.705320237173026, 3.188294924425105,
                    3.690282876998356, 4.218609444386561, 4.785320367352224, 5.413636355280034, 6.164272434052452};
        case (26):
            return {-6.309550385625694, -5.564524981950103, -4.941324957241379, -4.379602662983305, -3.856288419909149,
                    -3.35942718235083, -2.881762219543087, -2.418415764773779, -1.965854785641137, -1.521361516651921,
                    -1.082733011077883, -0.6480952139934483, -0.2157778562434634, 0.2157778562434634,
                    0.6480952139934483, 1.082733011077883, 1.521361516651921, 1.965854785641137, 2.418415764773779,
                    2.881762219543087, 3.35942718235083, 3.856288419909149, 4.379602662983305, 4.941324957241379,
                    5.564524981950103, 6.309550385625694};
        case (27):
            return {-6.451940140753472, -5.712255552816537, -5.093910003113184, -4.536906663372442, -4.018318670408739,
                    -3.526275340134353, -3.053582419822255, -2.595416338910818, -2.148296645361627, -1.709560739260337,
                    -1.277066817339858, -0.8490113420601031, -0.423807900543853, 0, 0.423807900543853,
                    0.8490113420601031, 1.277066817339858, 1.709560739260337, 2.148296645361627, 2.595416338910818,
                    3.053582419822255, 3.526275340134353, 4.018318670408739, 4.536906663372442, 5.093910003113184,
                    5.712255552816537, 6.451940140753472};
        case (28):
            return {-6.591605442367743, -5.857014641382851, -5.243285373202936, -4.690756523943118, -4.176636742129268,
                    -3.689134238461679, -3.221112076561456, -2.767795352913594, -2.325749842656441, -1.892360496837685,
                    -1.465537263457409, -1.043535273754208, -0.6248367195052092, -0.2080673826907369,
                    0.2080673826907369, 0.6248367195052092, 1.043535273754208, 1.465537263457409, 1.892360496837685,
                    2.325749842656441, 2.767795352913594, 3.221112076561456, 3.689134238461679, 4.176636742129268,
                    4.690756523943118, 5.243285373202936, 5.857014641382851, 6.591605442367743};
        case (29):
            return {-6.72869519860885, -5.99897128946382, -5.389640521966752, -4.841363651059164, -4.33147829381915,
                    -3.84826679221362, -3.384645141092214, -2.935882504290126, -2.498585691019404, -2.070181076053428,
                    -1.648622913892316, -1.232215755084753, -0.8194986812709116, -0.4091646363949287, 0,
                    0.4091646363949287, 0.8194986812709116, 1.232215755084753, 1.648622913892316, 2.070181076053428,
                    2.498585691019404, 2.935882504290126, 3.384645141092214, 3.84826679221362, 4.33147829381915,
                    4.841363651059164, 5.389640521966752, 5.99897128946382, 6.72869519860885};
        case (30):
            return {-6.863345293529892, -6.138279220123935, -5.533147151567496, -4.988918968589944, -4.483055357092518,
                    -4.003908603861229, -3.54444387315535, -3.099970529586442, -2.667132124535617, -2.243391467761504,
                    -1.826741143603688, -1.415527800198189, -1.008338271046723, -0.6039210586255523,
                    -0.2011285765488715, 0.2011285765488715, 0.6039210586255523, 1.008338271046723, 1.415527800198189,
                    1.826741143603688, 2.243391467761504, 2.667132124535617, 3.099970529586442, 3.54444387315535,
                    4.003908603861229, 4.483055357092518, 4.988918968589944, 5.533147151567496, 6.138279220123935,
                    6.863345293529892};
        case (31):
            return {-6.99568012371854, -6.27507870494286, -5.673961444618588, -5.133595577112381, -4.63155950631286,
                    -4.156271755818145, -3.700743403231469, -3.260320732313541, -2.831680453390205, -2.41231770548042,
                    -2.000258548935639, -1.59388586047214, -1.191826998350046, -0.7928769769153089, -0.3959427364714231,
                    0, 0.3959427364714231, 0.7928769769153089, 1.191826998350046, 1.59388586047214, 2.000258548935639,
                    2.41231770548042, 2.831680453390205, 3.260320732313541, 3.700743403231469, 4.156271755818145,
                    4.63155950631286, 5.133595577112381, 5.673961444618588, 6.27507870494286, 6.99568012371854};
        case (32):
            return {-7.125813909830728, -6.40949814926966, -5.812225949515914, -5.27555098651588, -4.777164503502596,
                    -4.305547953351198, -3.853755485471445, -3.417167492818571, -2.992490825002374, -2.577249537732317,
                    -2.169499183606112, -1.767654109463202, -1.370376410952872, -0.9765004635896828,
                    -0.5849787654359324, -0.1948407415693993, 0.1948407415693993, 0.5849787654359324,
                    0.9765004635896828, 1.370376410952872, 1.767654109463202, 2.169499183606112, 2.577249537732317,
                    2.992490825002374, 3.417167492818571, 3.853755485471445, 4.305547953351198, 4.777164503502596,
                    5.27555098651588, 5.812225949515914, 6.40949814926966, 7.125813909830728};
        case (33):
            return {-7.253851822015201, -6.541655445738077, -5.948071182087144, -5.414929002614193, -4.920028520595008,
                    -4.451911148832827, -4.003671609956931, -3.570721980232718, -3.149796681703825, -2.738445824351355,
                    -2.334751151529515, -1.937154581822207, -1.544348261243122, -1.15520020412679, -0.7687013797588687,
                    -0.3839260145084091, 0, 0.3839260145084091, 0.7687013797588687, 1.15520020412679, 1.544348261243122,
                    1.937154581822207, 2.334751151529515, 2.738445824351355, 3.149796681703825, 3.570721980232718,
                    4.003671609956931, 4.451911148832827, 4.920028520595008, 5.414929002614193, 5.948071182087144,
                    6.541655445738077, 7.253851822015201};
        case (34):
            return {-7.379890950481246, -6.67165913607017, -6.081616993936316, -5.551861330988778, -5.060296018605762,
                    -4.59551974810817, -4.150665602970781, -3.721175232476153, -3.303808431564416, -2.896138943174432,
                    -2.496271940816547, -2.102673690467333, -1.714062553387338, -1.329335551884786, -0.9475164580334473,
                    -0.5677172685548746, -0.1891080605271425, 0.1891080605271425, 0.5677172685548746,
                    0.9475164580334473, 1.329335551884786, 1.714062553387338, 2.102673690467333, 2.496271940816547,
                    2.896138943174432, 3.303808431564416, 3.721175232476153, 4.150665602970781, 4.59551974810817,
                    5.060296018605762, 5.551861330988778, 6.081616993936316, 6.67165913607017, 7.379890950481246};
        case (35):
            return {-7.504021146448936, -6.79960941328413, -6.212973747633717, -5.686468948090442, -5.198099346197753,
                    -4.736518477413211, -4.294895814492763, -3.868700730969154, -3.454716495751991, -3.050538420430447,
                    -2.654292781197172, -2.264467501042569, -1.879803988730917, -1.49922448861173, -1.121780990720303,
                    -0.746617639879867, -0.3729417170496169, 0, 0.3729417170496169, 0.746617639879867,
                    1.121780990720303, 1.49922448861173, 1.879803988730917, 2.264467501042569, 2.654292781197172,
                    3.050538420430447, 3.454716495751991, 3.868700730969154, 4.294895814492763, 4.736518477413211,
                    5.198099346197753, 5.686468948090442, 6.212973747633717, 6.79960941328413, 7.504021146448936};
        case (36):
            return {-7.626325754003894, -6.925598990259942, -6.342243330994412, -5.818863279505577, -5.333560107113064,
                    -4.875039972467084, -4.436506970192857, -4.01345656774947, -3.602693857148476, -3.201833945788159,
                    -2.809022235131104, -2.422766042053562, -2.04182718355442, -1.665150001843414, -1.291810958820924,
                    -0.920981801570753, -0.5519014332904228, -0.1838533671058128, 0.1838533671058128,
                    0.5519014332904228, 0.920981801570753, 1.291810958820924, 1.665150001843414, 2.04182718355442,
                    2.422766042053562, 2.809022235131104, 3.201833945788159, 3.602693857148476, 4.01345656774947,
                    4.436506970192857, 4.875039972467084, 5.333560107113064, 5.818863279505577, 6.342243330994412,
                    6.925598990259942, 7.626325754003894};
        case (37):
            return {-7.746882249649456, -7.049713855778229, -6.469520036524031, -5.949147217461971, -5.46679033596856,
                    -5.011206138573073, -4.575631748667359, -4.155587281126479, -3.74789820647548, -3.350197894972536,
                    -2.960649181303289, -2.577776858113272, -2.200360934009252, -1.827365248763605, -1.457887646874209,
                    -1.091123764975933, -0.7263396166051203, -0.362849905050658, 0, 0.362849905050658,
                    0.7263396166051203, 1.091123764975933, 1.457887646874209, 1.827365248763605, 2.200360934009252,
                    2.577776858113272, 2.960649181303289, 3.350197894972536, 3.74789820647548, 4.155587281126479,
                    4.575631748667359, 5.011206138573073, 5.46679033596856, 5.949147217461971, 6.469520036524031,
                    7.049713855778229, 7.746882249649456};
        case (38):
            return {-7.865762803380041, -7.172033935320031, -6.594891327265494, -6.077416003537561, -5.597893514184678,
                    -5.145129320740823, -4.712392132084888, -4.295225419749605, -3.890473760963341, -3.495787454835627,
                    -3.109345311717942, -2.729687962888326, -2.355611733035508, -1.986097778039066, -1.620262755633014,
                    -1.257323131700713, -0.896568346193136, -0.5373398108709835, -0.1790137232958775,
                    0.1790137232958775, 0.5373398108709835, 0.896568346193136, 1.257323131700713, 1.620262755633014,
                    1.986097778039066, 2.355611733035508, 2.729687962888326, 3.109345311717942, 3.495787454835627,
                    3.890473760963341, 4.295225419749605, 4.712392132084888, 5.145129320740823, 5.597893514184678,
                    6.077416003537561, 6.594891327265494, 7.172033935320031, 7.865762803380041};
        case (39):
            return {-7.983034772719781, -7.292633670865721, -6.718438506444093, -6.20375799772811, -5.726965451782105,
                    -5.276913315230426, -4.846900568743526, -4.432492882593037, -4.030552814602468, -3.638746424874536,
                    -3.255267235992229, -2.878670311374955, -2.507766693891319, -2.14155301198688, -1.779162582854313,
                    -1.419830157685736, -1.062865567281179, -0.7076332733485723, -0.3535358469963293, 0,
                    0.3535358469963293, 0.7076332733485723, 1.062865567281179, 1.419830157685736, 1.779162582854313,
                    2.14155301198688, 2.507766693891319, 2.878670311374955, 3.255267235992229, 3.638746424874536,
                    4.030552814602468, 4.432492882593037, 4.846900568743526, 5.276913315230426, 5.726965451782105,
                    6.20375799772811, 6.718438506444093, 7.292633670865721, 7.983034772719781};
        case (40):
            return {-8.09876113925085, -7.411582531485469, -6.840237305249355, -6.328255351220082, -5.8540950560304,
                    -5.406654247970128, -4.979260978545256, -4.567502072844395, -4.1682570668325, -3.779206753435223,
                    -3.398558265859628, -3.024879883901284, -2.656995998442896, -2.293917141875083, -1.934791472282296,
                    -1.578869894931614, -1.225480109046289, -0.8740066123570881, -0.5238747138322772,
                    -0.1745372145975824, 0.1745372145975824, 0.5238747138322772, 0.8740066123570881, 1.225480109046289,
                    1.578869894931614, 1.934791472282296, 2.293917141875083, 2.656995998442896, 3.024879883901284,
                    3.398558265859628, 3.779206753435223, 4.1682570668325, 4.567502072844395, 4.979260978545256,
                    5.406654247970128, 5.8540950560304, 6.328255351220082, 6.840237305249355, 7.411582531485469,
                    8.09876113925085};
        case (100):
            return {-13.40648733814491, -12.82379974948781, -12.34296422285967,

                    -11.91506194311417, -11.52141540078703, -11.15240438558513,

                    -10.80226075368471, -10.46718542134281, -10.14450994129285,

                    -9.832269807777969, -9.528965823390115, -9.233420890219162,

                    -8.944689217325474, -8.661996168134518, -8.384696940416265,

                    -8.112247311162792, -7.844182384460821, -7.580100807857489,

                    -7.319652822304535, -7.062531060248865, -6.808463352858796,

                    -6.557207031921539, -6.308544361112135, -6.062278832614303,

                    -5.818232135203517, -5.576241649329924, -5.336158360138360,

                    -5.097845105089136, -4.861175091791210, -4.626030635787156,

                    -4.392302078682684, -4.159886855131031, -3.928688683427671,

                    -3.698616859318492, -3.469585636418589, -3.241513679631013,

                    -3.014323580331156, -2.787941423981989, -2.562296402372608,

                    -2.337320463906879, -2.112947996371188, -1.889115537427008,

                    -1.665761508741509, -1.442825970215933, -1.220250391218953,

                    -0.9979774360981052, -0.7759507615401458, -0.5541148235916170,

                    -0.3324146923422318, -0.1107958724224395, 0.1107958724224395,

                    0.3324146923422318, 0.5541148235916170, 0.7759507615401458,

                    0.9979774360981052, 1.220250391218953, 1.442825970215933,

                    1.665761508741509, 1.889115537427008, 2.112947996371188,

                    2.337320463906879, 2.562296402372608, 2.787941423981989,

                    3.014323580331156, 3.241513679631013, 3.469585636418589,

                    3.698616859318492, 3.928688683427671, 4.159886855131031,

                    4.392302078682684, 4.626030635787156, 4.861175091791210,

                    5.097845105089136, 5.336158360138360, 5.576241649329924,

                    5.818232135203517, 6.062278832614303, 6.308544361112135,

                    6.557207031921539, 6.808463352858796, 7.062531060248865,

                    7.319652822304535, 7.580100807857489, 7.844182384460821,

                    8.112247311162792, 8.384696940416265, 8.661996168134518,

                    8.944689217325474, 9.233420890219162, 9.528965823390115,

                    9.832269807777969, 10.14450994129285, 10.46718542134281,

                    10.80226075368471, 11.15240438558513, 11.52141540078703,

                    11.91506194311417, 12.34296422285967, 12.82379974948781,

                    13.40648733814491};
        case (99):
            return {-13.40648733814491, -12.82379974948781, -12.34296422285967,

                    -11.91506194311417, -11.52141540078703, -11.15240438558513,

                    -10.80226075368471, -10.46718542134281, -10.14450994129285,

                    -9.832269807777969, -9.528965823390115, -9.233420890219162,

                    -8.944689217325474, -8.661996168134518, -8.384696940416265,

                    -8.112247311162792, -7.844182384460821, -7.580100807857489,

                    -7.319652822304535, -7.062531060248865, -6.808463352858796,

                    -6.557207031921539, -6.308544361112135, -6.062278832614303,

                    -5.818232135203517, -5.576241649329924, -5.336158360138360,

                    -5.097845105089136, -4.861175091791210, -4.626030635787156,

                    -4.392302078682684, -4.159886855131031, -3.928688683427671,

                    -3.698616859318492, -3.469585636418589, -3.241513679631013,

                    -3.014323580331156, -2.787941423981989, -2.562296402372608,

                    -2.337320463906879, -2.112947996371188, -1.889115537427008,

                    -1.665761508741509, -1.442825970215933, -1.220250391218953,

                    -0.9979774360981052, -0.7759507615401458, -0.5541148235916170,

                    -0.3324146923422318, -0.1107958724224395, 0.1107958724224395,

                    0.3324146923422318, 0.5541148235916170, 0.7759507615401458,

                    0.9979774360981052, 1.220250391218953, 1.442825970215933,

                    1.665761508741509, 1.889115537427008, 2.112947996371188,

                    2.337320463906879, 2.562296402372608, 2.787941423981989,

                    3.014323580331156, 3.241513679631013, 3.469585636418589,

                    3.698616859318492, 3.928688683427671, 4.159886855131031,

                    4.392302078682684, 4.626030635787156, 4.861175091791210,

                    5.097845105089136, 5.336158360138360, 5.576241649329924,

                    5.818232135203517, 6.062278832614303, 6.308544361112135,

                    6.557207031921539, 6.808463352858796, 7.062531060248865,

                    7.319652822304535, 7.580100807857489, 7.844182384460821,

                    8.112247311162792, 8.384696940416265, 8.661996168134518,

                    8.944689217325474, 9.233420890219162, 9.528965823390115,

                    9.832269807777969, 10.14450994129285, 10.46718542134281,

                    10.80226075368471, 11.15240438558513, 11.52141540078703,

                    11.91506194311417, 12.34296422285967, 12.82379974948781,

                    13.40648733814491};
        case (101):
            return {-13.40648733814491, -12.82379974948781, -12.34296422285967,

                    -11.91506194311417, -11.52141540078703, -11.15240438558513,

                    -10.80226075368471, -10.46718542134281, -10.14450994129285,

                    -9.832269807777969, -9.528965823390115, -9.233420890219162,

                    -8.944689217325474, -8.661996168134518, -8.384696940416265,

                    -8.112247311162792, -7.844182384460821, -7.580100807857489,

                    -7.319652822304535, -7.062531060248865, -6.808463352858796,

                    -6.557207031921539, -6.308544361112135, -6.062278832614303,

                    -5.818232135203517, -5.576241649329924, -5.336158360138360,

                    -5.097845105089136, -4.861175091791210, -4.626030635787156,

                    -4.392302078682684, -4.159886855131031, -3.928688683427671,

                    -3.698616859318492, -3.469585636418589, -3.241513679631013,

                    -3.014323580331156, -2.787941423981989, -2.562296402372608,

                    -2.337320463906879, -2.112947996371188, -1.889115537427008,

                    -1.665761508741509, -1.442825970215933, -1.220250391218953,

                    -0.9979774360981052, -0.7759507615401458, -0.5541148235916170,

                    -0.3324146923422318, -0.1107958724224395, 0.1107958724224395,

                    0.3324146923422318, 0.5541148235916170, 0.7759507615401458,

                    0.9979774360981052, 1.220250391218953, 1.442825970215933,

                    1.665761508741509, 1.889115537427008, 2.112947996371188,

                    2.337320463906879, 2.562296402372608, 2.787941423981989,

                    3.014323580331156, 3.241513679631013, 3.469585636418589,

                    3.698616859318492, 3.928688683427671, 4.159886855131031,

                    4.392302078682684, 4.626030635787156, 4.861175091791210,

                    5.097845105089136, 5.336158360138360, 5.576241649329924,

                    5.818232135203517, 6.062278832614303, 6.308544361112135,

                    6.557207031921539, 6.808463352858796, 7.062531060248865,

                    7.319652822304535, 7.580100807857489, 7.844182384460821,

                    8.112247311162792, 8.384696940416265, 8.661996168134518,

                    8.944689217325474, 9.233420890219162, 9.528965823390115,

                    9.832269807777969, 10.14450994129285, 10.46718542134281,

                    10.80226075368471, 11.15240438558513, 11.52141540078703,

                    11.91506194311417, 12.34296422285967, 12.82379974948781,

                    13.40648733814491};
        case (200):
            return {-19.33924866791141, -18.82289598056473, -18.39809656513218,

                    -18.02108150117317, -17.67512252996192, -17.35159677955040,

                    -17.04533115109215, -16.75291719139818, -16.47196038876288,

                    -16.20069793679210, -15.93778486889572, -15.68216565880975,

                    -15.43299278489287, -15.18957275696119, -14.95132902868146,

                    -14.71777573124730, -14.48849858757270, -14.26314073464826,

                    -14.04139198785555, -13.82298057356554, -13.60766666693806,

                    -13.39523727320802, -13.18550212454403, -12.97829035543407,

                    -12.77344778248851, -12.57083465891832, -12.37032380573050,

                    -12.17179904478713, -11.97515387589713, -11.78029035280524,

                    -11.58711812252034, -11.39555359972604, -11.20551925363643,

                    -11.01694298902518, -10.82975760657608, -10.64390033040279,

                    -10.45931239273354, -10.27593866747647, -10.09372734576829,

                    -9.912629647733797, -9.732599565601927, -9.553593634076821,

                    -9.375570724483644, -9.198491859723556, -9.022320047500836,

                    -8.847020129643674, -8.672558645641239, -8.498903708773607,

                    -8.326024893426122, -8.153893132362483, -7.982480622886646,

                    -7.811760740956943, -7.641707962430267, -7.472297790712723,

                    -7.303506690178222, -7.135312024790252, -6.967692001426046,

                    -6.800625617458123, -6.634092612196868, -6.468073421840371,

                    -6.302549137615144, -6.137501466824152, -5.972912696547550,

                    -5.808765659767065, -5.645043703707577, -5.481730660209469,

                    -5.318810817963144, -5.156268896452903, -4.994090021471522,

                    -4.832259702079436, -4.670763808893703, -4.509588553602011,

                    -4.348720469606021, -4.188146393706468, -4.027853448749714,

                    -3.867829027162057, -3.708060775303960, -3.548536578581765,

                    -3.389244547259216, -3.230173002915508, -3.071310465500502,

                    -2.912645640941291, -2.754167409257548, -2.595864813145972,

                    -2.437727046996821, -2.279743446307864, -2.121903477463271,

                    -1.964196727846910, -1.806612896261253, -1.649141783624695,

                    -1.491773283921519, -1.334497375379992, -1.177304111855233,

                    -1.020183614394495, -0.8631260629633961, -0.7061216883124085,

                    -0.5491607639635989, -0.3922335982981664, -0.2353305267258213,

                    -0.07844190391742080, 0.07844190391742080, 0.2353305267258213,

                    0.3922335982981664, 0.5491607639635989, 0.7061216883124085,

                    0.8631260629633961, 1.020183614394495, 1.177304111855233,

                    1.334497375379992, 1.491773283921519, 1.649141783624695,

                    1.806612896261253, 1.964196727846910, 2.121903477463271,

                    2.279743446307864, 2.437727046996821, 2.595864813145972,

                    2.754167409257548, 2.912645640941291, 3.071310465500502,

                    3.230173002915508, 3.389244547259216, 3.548536578581765,

                    3.708060775303960, 3.867829027162057, 4.027853448749714,

                    4.188146393706468, 4.348720469606021, 4.509588553602011,

                    4.670763808893703, 4.832259702079436, 4.994090021471522,

                    5.156268896452903, 5.318810817963144, 5.481730660209469,

                    5.645043703707577, 5.808765659767065, 5.972912696547550,

                    6.137501466824152, 6.302549137615144, 6.468073421840371,

                    6.634092612196868, 6.800625617458123, 6.967692001426046,

                    7.135312024790252, 7.303506690178222, 7.472297790712723,

                    7.641707962430267, 7.811760740956943, 7.982480622886646,

                    8.153893132362483, 8.326024893426122, 8.498903708773607,

                    8.672558645641239, 8.847020129643674, 9.022320047500836,

                    9.198491859723556, 9.375570724483644, 9.553593634076821,

                    9.732599565601927, 9.912629647733797, 10.09372734576829,

                    10.27593866747647, 10.45931239273354, 10.64390033040279,

                    10.82975760657608, 11.01694298902518, 11.20551925363643,

                    11.39555359972604, 11.58711812252034, 11.78029035280524,

                    11.97515387589713, 12.17179904478713, 12.37032380573050,

                    12.57083465891832, 12.77344778248851, 12.97829035543407,

                    13.18550212454403, 13.39523727320802, 13.60766666693806,

                    13.82298057356554, 14.04139198785555, 14.26314073464826,

                    14.48849858757270, 14.71777573124730, 14.95132902868146,

                    15.18957275696119, 15.43299278489287, 15.68216565880975,

                    15.93778486889572, 16.20069793679210, 16.47196038876288,

                    16.75291719139818, 17.04533115109215, 17.35159677955040,

                    17.67512252996192, 18.02108150117317, 18.39809656513218,

                    18.82289598056473, 19.33924866791141};
        case (300):
            return {-23.87480976369421, -23.39323523106598, -22.99751746387306,

                    -22.64667666713379, -22.32504339470689, -22.02453745024748,

                    -21.74030968976190, -21.46916418429526, -21.20885516340669,

                    -20.95772896860282, -20.71452368443499, -20.47824882040381,

                    -20.24810898760329, -20.02345330547170, -19.80374063112534,

                    -19.58851493013949, -19.37738737763031, -19.17002306035376,

                    -18.96613090577730, -18.76545592555236, -18.56777315184876,

                    -18.37288283371995, -18.18060658606586, -17.99078426893132,

                    -17.80327143387268, -17.61793721571807, -17.43466257784556,

                    -17.25333884076723, -17.07386643976866, -16.89615386925956,

                    -16.72011678047321, -16.54567720600031, -16.37276288991433,

                    -16.20130670634041, -16.03124615252848, -15.86252290502381,

                    -15.69508242954415, -15.52887363678604, -15.36384857768494,

                    -15.19996217270926, -15.03717197063025, -14.87543793291619,

                    -14.71472224048277, -14.55498912001445, -14.39620468747418,

                    -14.23833680675539, -14.08135496171294, -13.92523014004822,

                    -13.76993472772547, -13.61544241276816, -13.46172809743035,

                    -13.30876781786347, -13.15653867050635, -13.00501874451895,

                    -12.85418705966014, -12.70402350907941, -12.55450880655225,

                    -12.40562443774160, -12.25735261511341, -12.10967623617453,

                    -11.96257884473610, -11.81604459493673, -11.67005821778691,

                    -11.52460499002012, -11.37967070505746, -11.23524164591153,

                    -11.09130455987193, -10.94784663482989, -10.80485547711273,

                    -10.66231909071080, -10.52022585779007, -10.37856452039344,

                    -10.23732416324191, -10.09649419755491, -9.956064345815810,

                    -9.816024627414845, -9.676365345107526, -9.537077072231577,

                    -9.398150640630130, -9.259577129233089, -9.121347853252412,

                    -8.983454353950494, -8.845888388944035, -8.708641923008601,

                    -8.571707119351765, -8.435076331325057, -8.298742094547204,

                    -8.162697119413081, -8.026934283964702, -7.891446627102203,

                    -7.756227342114359, -7.621269770509592, -7.486567396129712,

                    -7.352113839529883, -7.217902852609362, -7.083928313478631,

                    -6.950184221549468, -6.816664692835362, -6.683363955450514,

                    -6.550276345296394, -6.417396301925520, -6.284718364572767,

                    -6.152237168345112, -6.019947440561267, -5.887843997233171,

                    -5.755921739681785, -5.624175651280070, -5.492600794316459,

                    -5.361192306972492, -5.229945400408671, -5.098855355952889,

                    -4.967917522386129, -4.837127313320404, -4.706480204664178,

                    -4.575971732170768, -4.445597489065449, -4.315353123747231,

                    -4.185234337561447, -4.055236882639511, -3.925356559802380,

                    -3.795589216524404, -3.665930744954437, -3.536377079991200,

                    -3.406924197410035, -3.277568112038335, -3.148304875977024,

                    -3.019130576865593, -2.890041336188311, -2.761033307619307,

                    -2.632102675404322, -2.503245652777030, -2.374458480407872,

                    -2.245737424883463, -2.117078777214671, -1.988478851371543,

                    -1.859933982843318, -1.731440527221813, -1.602994858806522,

                    -1.474593369229829, -1.346232466100748, -1.217908571665690,

                    -1.089618121484735, -0.9613575631219852, -0.8331233548485442,

                    -0.7049119643567409, -0.5767198674842104, -0.4485435469464817,

                    -0.3203794910767310, -0.1922241925713787, -0.06407414724021921,

                    0.06407414724021921, 0.1922241925713787, 0.3203794910767310,

                    0.4485435469464817, 0.5767198674842104, 0.7049119643567409,

                    0.8331233548485442, 0.9613575631219852, 1.089618121484735,

                    1.217908571665690, 1.346232466100748, 1.474593369229829,

                    1.602994858806522, 1.731440527221813, 1.859933982843318,

                    1.988478851371543, 2.117078777214671, 2.245737424883463,

                    2.374458480407872, 2.503245652777030, 2.632102675404322,

                    2.761033307619307, 2.890041336188311, 3.019130576865593,

                    3.148304875977024, 3.277568112038335, 3.406924197410035,

                    3.536377079991200, 3.665930744954437, 3.795589216524404,

                    3.925356559802380, 4.055236882639511, 4.185234337561447,

                    4.315353123747231, 4.445597489065449, 4.575971732170768,

                    4.706480204664178, 4.837127313320404, 4.967917522386129,

                    5.098855355952889, 5.229945400408671, 5.361192306972492,

                    5.492600794316459, 5.624175651280070, 5.755921739681785,

                    5.887843997233171, 6.019947440561267, 6.152237168345112,

                    6.284718364572767, 6.417396301925520, 6.550276345296394,

                    6.683363955450514, 6.816664692835362, 6.950184221549468,

                    7.083928313478631, 7.217902852609362, 7.352113839529883,

                    7.486567396129712, 7.621269770509592, 7.756227342114359,

                    7.891446627102203, 8.026934283964702, 8.162697119413081,

                    8.298742094547204, 8.435076331325057, 8.571707119351765,

                    8.708641923008601, 8.845888388944035, 8.983454353950494,

                    9.121347853252412, 9.259577129233089, 9.398150640630130,

                    9.537077072231577, 9.676365345107526, 9.816024627414845,

                    9.956064345815810, 10.09649419755491, 10.23732416324191,

                    10.37856452039344, 10.52022585779007, 10.66231909071080,

                    10.80485547711273, 10.94784663482989, 11.09130455987193,

                    11.23524164591153, 11.37967070505746, 11.52460499002012,

                    11.67005821778691, 11.81604459493673, 11.96257884473610,

                    12.10967623617453, 12.25735261511341, 12.40562443774160,

                    12.55450880655225, 12.70402350907941, 12.85418705966014,

                    13.00501874451895, 13.15653867050635, 13.30876781786347,

                    13.46172809743035, 13.61544241276816, 13.76993472772547,

                    13.92523014004822, 14.08135496171294, 14.23833680675539,

                    14.39620468747418, 14.55498912001445, 14.71472224048277,

                    14.87543793291619, 15.03717197063025, 15.19996217270926,

                    15.36384857768494, 15.52887363678604, 15.69508242954415,

                    15.86252290502381, 16.03124615252848, 16.20130670634041,

                    16.37276288991433, 16.54567720600031, 16.72011678047321,

                    16.89615386925956, 17.07386643976866, 17.25333884076723,

                    17.43466257784556, 17.61793721571807, 17.80327143387268,

                    17.99078426893132, 18.18060658606586, 18.37288283371995,

                    18.56777315184876, 18.76545592555236, 18.96613090577730,

                    19.17002306035376, 19.37738737763031, 19.58851493013949,

                    19.80374063112534, 20.02345330547170, 20.24810898760329,

                    20.47824882040381, 20.71452368443499, 20.95772896860282,

                    21.20885516340669, 21.46916418429526, 21.74030968976190,

                    22.02453745024748, 22.32504339470689, 22.64667666713379,

                    22.99751746387306, 23.39323523106598, 23.87480976369421};
        case (500):
            return {-31.05074638009002, -30.60936029244094, -30.24705852829922,

                    -29.92614541793549, -29.63220091755680, -29.35778628597730,

                    -29.09843582425251, -28.85120541913383, -28.61402567175311,

                    -28.38537240336434, -28.16408223225874, -27.94924181217199,

                    -27.74011755966420, -27.53610906449128, -27.33671706561000,

                    -27.14152076418081, -26.95016133377198, -26.76232966765113,

                    -26.57775709815377, -26.39620824788594, -26.21747544042715,

                    -26.04137427192869, -25.86774006045762, -25.69642496836079,

                    -25.52729564724941, -25.36023129350902, -25.19512202968502,

                    -25.03186754704802, -24.87037595934632, -24.71056282872139,

                    -24.55235033303724, -24.39566655018397, -24.24044483977325,

                    -24.08662330641722, -23.93414433173875, -23.78295416459585,

                    -23.63300256086035, -23.48424246557893, -23.33662973154425,

                    -23.19012286927735, -23.04468282421687, -22.90027277756229,

                    -22.75685796775608, -22.61440553003518, -22.47288435185340,

                    -22.33226494228678, -22.19251931379468, -22.05362087492943,

                    -21.91554433277360, -21.77826560404228, -21.64176173392272,

                    -21.50601082183941, -21.37099195343170, -21.23668513811651,

                    -21.10307125168277, -20.97013198342767, -20.83784978740093,

                    -20.70620783737110, -20.57518998517069, -20.44478072211337,

                    -20.31496514320947, -20.18572891393409, -20.05705823932749,

                    -19.92893983522975, -19.80136090147114, -19.67430909685708,

                    -19.54777251580239, -19.42173966648291, -19.29619945038507,

                    -19.17114114314514, -19.04655437657929, -18.92242912181500,

                    -18.79875567344167, -18.67552463460591, -18.55272690298307,

                    -18.43035365756255, -18.30839634618949, -18.18684667381039,

                    -18.06569659137423, -17.94493828534473, -17.82456416778295,

                    -17.70456686696230, -17.58493921848154, -17.46567425684331,

                    -17.34676520746879, -17.22820547912090, -17.10998865671059,

                    -16.99210849446274, -16.87455890941970, -16.75733397526225,

                    -16.64042791642900, -16.52383510251673, -16.40755004294535,

                    -16.29156738187214, -16.17588189334122, -16.06048847665482,

                    -15.94538215195413, -15.83055805599808, -15.71601143812922,

                    -15.60173765641664, -15.48773217396642, -15.37399055539070,

                    -15.26050846342706, -15.14728165570042, -15.03430598162006,

                    -14.92157737940496, -14.80909187323081, -14.69684557049280,

                    -14.58483465917831, -14.47305540534410, -14.36150415069302,

                    -14.25017731024523, -14.13907137009969, -14.02818288528133,

                    -13.91750847767015, -13.80704483400815, -13.69678870398083,

                    -13.58673689836946, -13.47688628727123, -13.36723379838404,

                    -13.25777641535308, -13.14851117617645, -13.03943517166729,

                    -12.93054554396983, -12.82183948512718, -12.71331423569846,

                    -12.60496708342332, -12.49679536193178, -12.38879644949748,

                    -12.28096776783253, -12.17330678092227, -12.06581099389830,

                    -11.95847795194816, -11.85130523926028, -11.74429047800264,

                    -11.63743132733400, -11.53072548244618, -11.42417067363634,

                    -11.31776466540801, -11.21150525559977, -11.10539027454052,

                    -10.99941758423035, -10.89358507754593, -10.78789067746967,

                    -10.68233233634155, -10.57690803513299, -10.47161578274175,

                    -10.36645361530720, -10.26141959554522, -10.15651181210193,

                    -10.05172837892562, -9.947067434656297, -9.842527142032038,

                    -9.738105687311768, -9.633801279713705, -9.529612150869025,

                    -9.425536554290171, -9.321572764853318, -9.217719078294488,

                    -9.113973810718856, -9.010335298122792, -8.906801895928211,

                    -8.803371978528800, -8.700043938847736, -8.596816187906507,

                    -8.493687154404455, -8.390655284308696, -8.287719040454071,

                    -8.184876902152789, -8.082127364813457, -7.979468939569175,

                    -7.876900152914423, -7.774419546350423, -7.672025676038734,

                    -7.569717112462792, -7.467492440097156, -7.365350257084196,

                    -7.263289174918005, -7.161307818135286, -7.059404824013015,

                    -6.957578842272638, -6.855828534790618, -6.754152575315129,

                    -6.652549649188687, -6.551018453076553, -6.449557694700715,

                    -6.348166092579275, -6.246842375771080, -6.145585283625419,

                    -6.044393565536642, -5.943265980703542, -5.842201297893345,

                    -5.741198295210180, -5.640255759867868, -5.539372487966915,

                    -5.438547284275564, -5.337778962014788, -5.237066342647093,

                    -5.136408255669011, -5.035803538407178, -4.935251035817871,

                    -4.834749600289897, -4.734298091450732, -4.633895375975804,

                    -4.533540327400816, -4.433231825937011, -4.332968758289293,

                    -4.232750017477094, -4.132574502657915, -4.032441118953432,

                    -3.932348777278107, -3.832296394170189, -3.732282891625053,

                    -3.632307196930776, -3.532368242505883, -3.432464965739180,

                    -3.332596308831608, -3.232761218640033, -3.132958646522919,

                    -3.033187548187789, -2.933446883540435, -2.833735616535784,

                    -2.734052715030374, -2.634397150636366, -2.534767898577028,

                    -2.435163937543636, -2.335584249553732, -2.236027819810665,

                    -2.136493636564378, -2.036980690973367, -1.937487976967763,

                    -1.838014491113478, -1.738559232477368, -1.639121202493338,

                    -1.539699404829371, -1.440292845255386, -1.340900531511915,

                    -1.241521473179508, -1.142154681548852, -1.042799169491520,

                    -0.9434539513313323, -0.8441180427162506, -0.7447904604907794,

                    -0.6454702225688129, -0.5461563478068844, -0.4468478558777691,

                    -0.3475437671443920, -0.2482431025339947, -0.1489448834125132,

                    -0.04964813145911949, 0.04964813145911949, 0.1489448834125132,

                    0.2482431025339947, 0.3475437671443920, 0.4468478558777691,

                    0.5461563478068844, 0.6454702225688129, 0.7447904604907794,

                    0.8441180427162506, 0.9434539513313323, 1.042799169491520,

                    1.142154681548852, 1.241521473179508, 1.340900531511915,

                    1.440292845255386, 1.539699404829371, 1.639121202493338,

                    1.738559232477368, 1.838014491113478, 1.937487976967763,

                    2.036980690973367, 2.136493636564378, 2.236027819810665,

                    2.335584249553732, 2.435163937543636, 2.534767898577028,

                    2.634397150636366, 2.734052715030374, 2.833735616535784,

                    2.933446883540435, 3.033187548187789, 3.132958646522919,

                    3.232761218640033, 3.332596308831608, 3.432464965739180,

                    3.532368242505883, 3.632307196930776, 3.732282891625053,

                    3.832296394170189, 3.932348777278107, 4.032441118953432,

                    4.132574502657915, 4.232750017477094, 4.332968758289293,

                    4.433231825937011, 4.533540327400816, 4.633895375975804,

                    4.734298091450732, 4.834749600289897, 4.935251035817871,

                    5.035803538407178, 5.136408255669011, 5.237066342647093,

                    5.337778962014788, 5.438547284275564, 5.539372487966915,

                    5.640255759867868, 5.741198295210180, 5.842201297893345,

                    5.943265980703542, 6.044393565536642, 6.145585283625419,

                    6.246842375771080, 6.348166092579275, 6.449557694700715,

                    6.551018453076553, 6.652549649188687, 6.754152575315129,

                    6.855828534790618, 6.957578842272638, 7.059404824013015,

                    7.161307818135286, 7.263289174918005, 7.365350257084196,

                    7.467492440097156, 7.569717112462792, 7.672025676038734,

                    7.774419546350423, 7.876900152914423, 7.979468939569175,

                    8.082127364813457, 8.184876902152789, 8.287719040454071,

                    8.390655284308696, 8.493687154404455, 8.596816187906507,

                    8.700043938847736, 8.803371978528800, 8.906801895928211,

                    9.010335298122792, 9.113973810718856, 9.217719078294488,

                    9.321572764853318, 9.425536554290171, 9.529612150869025,

                    9.633801279713705, 9.738105687311768, 9.842527142032038,

                    9.947067434656297, 10.05172837892562, 10.15651181210193,

                    10.26141959554522, 10.36645361530720, 10.47161578274175,

                    10.57690803513299, 10.68233233634155, 10.78789067746967,

                    10.89358507754593, 10.99941758423035, 11.10539027454052,

                    11.21150525559977, 11.31776466540801, 11.42417067363634,

                    11.53072548244618, 11.63743132733400, 11.74429047800264,

                    11.85130523926028, 11.95847795194816, 12.06581099389830,

                    12.17330678092227, 12.28096776783253, 12.38879644949748,

                    12.49679536193178, 12.60496708342332, 12.71331423569846,

                    12.82183948512718, 12.93054554396983, 13.03943517166729,

                    13.14851117617645, 13.25777641535308, 13.36723379838404,

                    13.47688628727123, 13.58673689836946, 13.69678870398083,

                    13.80704483400815, 13.91750847767015, 14.02818288528133,

                    14.13907137009969, 14.25017731024523, 14.36150415069302,

                    14.47305540534410, 14.58483465917831, 14.69684557049280,

                    14.80909187323081, 14.92157737940496, 15.03430598162006,

                    15.14728165570042, 15.26050846342706, 15.37399055539070,

                    15.48773217396642, 15.60173765641664, 15.71601143812922,

                    15.83055805599808, 15.94538215195413, 16.06048847665482,

                    16.17588189334122, 16.29156738187214, 16.40755004294535,

                    16.52383510251673, 16.64042791642900, 16.75733397526225,

                    16.87455890941970, 16.99210849446274, 17.10998865671059,

                    17.22820547912090, 17.34676520746879, 17.46567425684331,

                    17.58493921848154, 17.70456686696230, 17.82456416778295,

                    17.94493828534473, 18.06569659137423, 18.18684667381039,

                    18.30839634618949, 18.43035365756255, 18.55272690298307,

                    18.67552463460591, 18.79875567344167, 18.92242912181500,

                    19.04655437657929, 19.17114114314514, 19.29619945038507,

                    19.42173966648291, 19.54777251580239, 19.67430909685708,

                    19.80136090147114, 19.92893983522975, 20.05705823932749,

                    20.18572891393409, 20.31496514320947, 20.44478072211337,

                    20.57518998517069, 20.70620783737110, 20.83784978740093,

                    20.97013198342767, 21.10307125168277, 21.23668513811651,

                    21.37099195343170, 21.50601082183941, 21.64176173392272,

                    21.77826560404228, 21.91554433277360, 22.05362087492943,

                    22.19251931379468, 22.33226494228678, 22.47288435185340,

                    22.61440553003518, 22.75685796775608, 22.90027277756229,

                    23.04468282421687, 23.19012286927735, 23.33662973154425,

                    23.48424246557893, 23.63300256086035, 23.78295416459585,

                    23.93414433173875, 24.08662330641722, 24.24044483977325,

                    24.39566655018397, 24.55235033303724, 24.71056282872139,

                    24.87037595934632, 25.03186754704802, 25.19512202968502,

                    25.36023129350902, 25.52729564724941, 25.69642496836079,

                    25.86774006045762, 26.04137427192869, 26.21747544042715,

                    26.39620824788594, 26.57775709815377, 26.76232966765113,

                    26.95016133377198, 27.14152076418081, 27.33671706561000,

                    27.53610906449128, 27.74011755966420, 27.94924181217199,

                    28.16408223225874, 28.38537240336434, 28.61402567175311,

                    28.85120541913383, 29.09843582425251, 29.35778628597730,

                    29.63220091755680, 29.92614541793549, 30.24705852829922,

                    30.60936029244094, 31.05074638009002
            };
        default:
            return {};
    }
}

// todo maybe put it below directly?
inline double hermite_w(int n, double root, double log_fact) {
    double h = hermitel(n - 1, root);
    if (h == 0) return 0; // Avoid division by zero
    double log_out = log_fact - 2 * log(abs(h))
                     + (n - 1) * log(2) + 0.5 * log(M_PI)
                     - 2 * log(n);
    return exp(log_out);
}

vector<double> Hweights(int my_n) {
    my_n++;
    vector<double> weights(my_n, 0);
    vector<double> roots = Hroots(my_n);

    // Compute log(my_n!) instead of factorial(my_n)
    double log_fact = 0.0;
    for (int k = 1; k <= my_n; ++k) {
        log_fact += log(k);
    }

    for (int i = 0; i < my_n; ++i) {
        weights[i] = hermite_w(my_n, roots[i], log_fact);
    }

    return weights;
}


void setQ() {
    Q_mat = VectorXd::Zero(sizeX);
    for (int i = 0; i < sizeX; i++) {
        Q_mat(i) = 1.0 / double(sizeX);
    }
    //cout << endl << "Q" << endl << Q_mat << endl;
}

void setPI() {
    vector<double> hweights = Hweights(n - 1); // todo change n
    vector<double> windows;

    PI_mat = MatrixXd::Zero(sizeX, n * n * sizeX);
    //for(auto h: hweights){  cout << "weights: " << h << endl; }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            windows.push_back(hweights[j] * hweights[i]); // windows is size n*n
        }
    }

    //for(auto w: windows){  cout << "windows: " << w << endl; }

    for (int i = 0; i < sizeX; i++) {
        int a = 0;
        for (int j = i * n * n; j < i * n * n + n * n; j++) {
            PI_mat(i, j) = windows[a];//all_hweights[n][i]*all_hweights[n][j]
            a++;
        }
    }
    //cout << endl << "PI: " << endl << PI_mat << endl;
    //cout << PI_mat.rows() << " " << PI_mat.cols();
    //std::cout << "hweights size: " << hweights.size() << "\n"; // Should be n
}

void setW() {
    //W_mat = MatrixXd::Zero(sizeX, n*n*sizeX);
    vector<double> roots = Hroots(n);
    vector<complex<double>> complexroots; // n*n
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            complexroots.push_back(complex<double>(roots[i], roots[j]));
        }
    }
    /*
    cout << endl << "X: " << endl;
    for(auto x: X_mat){
        cout << x << endl;
    }


    cout << endl << "Z: " << endl;
    for(auto z: complexroots){
        cout << z << endl;
    }
    */
    VectorXcd Y(n * n * sizeX);
    int a = 0;
    for (int i = 0; i < n * n * sizeX; i += n * n) {
        for (int j = 0; j < n * n; j++) {
            Y(i + j) = sqrt(SNR) * X_mat(a);
            Y(i + j) += complexroots[j];
        }
        a++;
    }
    // cout << endl << "Y: " << endl << Y << endl;

    //MatrixXd D_mat(sizeX, n*n*sizeX);
    D_mat = MatrixXd::Zero(sizeX, n * n * sizeX);
    for (int i = 0; i < sizeX; i++) {
        for (int j = 0; j < n * n * sizeX; j++) {
            D_mat(i, j) = abs_sq(Y(j) - sqrt(SNR) * X_mat(i));
        }
    }
    //cout << endl << "D: " << endl << D_mat << endl;
    // cout << D_mat.rows() << " " << D_mat.cols();

    //W_mat = exp(-D_mat.array());

    //cout << endl << "W: " << endl <<W_mat << endl;
    // cout << endl << endl;
    // In setW():
    //std::cout << "roots size: " << roots.size() << "\n"; // Should be n
    //std::cout << "Y[0]: " << Y(0) << "\n"; // Should be X_mat[0] + complexroots[0]
}

void setX(int npoints, string xmode) {
    sizeX = npoints;
    X.resize(npoints);
    X_mat = VectorXd::Zero(sizeX);
    if (xmode == "PAM") { // pam
        float delta = sqrt(3 / (pow(npoints, 2) - 1));
        for (int n = 0; n < npoints / 2; n++) {
            X[n + npoints / 2] = (2 * n + 1) * delta;
            X_mat(n + npoints / 2) = (2 * n + 1) * delta;
        }

        for (int n = 0; n < npoints / 2; n++) {
            X[n] = -X[npoints - 1 - n];
            X_mat(n) = -X_mat(npoints - 1 - n);
        }
    } else if (xmode == "PSK") { // psk
        for (int n = 0; n < npoints; n++) {
            X[n] = (cos(2.0 * PI * double(n) / npoints) + I * sin(2.0 * PI * double(n) / npoints));
            X_mat(n) = (cos(2.0 * PI * double(n) / npoints) + I * sin(2.0 * PI * double(n) / npoints));
        }
    } else if (xmode == "secret") {
        for (int n = 0; n < npoints; n++) X[n] = (double(rand()) + I * double(rand()));
        //X = {-1/sqrt(2)-I*double(1/sqrt(2)), -1/sqrt(2)+I*double(1/sqrt(2)), +1/sqrt(2)-I*double(1/sqrt(2)), 1/sqrt(2)+I*double(1/sqrt(2))};
    } else {
        cout << "ERROR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
    }

    //cout << "X: " << X_mat << endl;
    /*
    cout << endl << "XXXXXX";
    for(int n = 0; n < npoints; n++){
        cout << X[n] << " ";
    }
    cout << endl;
     */
    /*
    for(auto x: X){
        qDebug("x,mod is %f+i%f,%d", real(x),imag(x), sizeX);
    }
    */

    /*
    if(DEBUG){
        for(auto x: X){
            qDebug("x,mod is %f+i%f,%d", real(x),imag(x), sizeX);
        }
    }
    */
}

void setA(vector<int> alphas) { // alphas
    A_mat = VectorXd::Zero(sizeX);
}

void setR(double r) {
    R = r;
}

void setSNR(double snr) {
    SNR = snr;
    //cout << "new SNR: " << SNR << endl;
}

void setMod(int mod, string xmode) {
    setX(mod, xmode);
}

std::chrono::microseconds sum_(vector<std::chrono::microseconds> vector1) {
    std:
    chrono::microseconds s = (std::chrono::microseconds) 0;
    for (auto x: vector1) {
        s += x;
    }
    return s;
}

string complextostr(complex<double> x) {
    return to_string(real(x)) + "+I*" + to_string(imag(x));
}

void initQ() {
    //qDebug() << "sx" << sizeX;
    double r, mysum = 0;
    for (int n = 0; n < sizeX; n++) {
        r = rand();
        Qq.push_back(r);
        mysum += r;
    }

    for (int n = 0; n < sizeX; n++) {
        //qDebug() << "qprev " << Qq[n];
        Qq[n] /= mysum;
        //qDebug() << "qpost " << Qq[n];
    }
    //qDebug() << mysum;
}

double Q(complex<double> x) {
    //return Qq[x];
    return 1.0 / double(sizeX);
}


inline double cost(complex<double> current_x) { // returns the cost function given x
    double out = abs_sq(current_x);
    int a = 0;
    for (auto x: X) {
        out -= Q(a) * abs_sq(x);
        a++;
    }
    //cout << "cost: " << out << endl;
    return out;
}

inline double W(complex<double> y, complex<double> x) {
    return 1 / PI * exp(-abs_sq(y - sqrt(SNR) * x));
}

inline double G(double alpha, complex<double> xhat, complex<double> y // a
        , double rho) {                                  // rho
    return exp(-rho * alpha) * pow(W(y, xhat), 1 / (1 + rho));
}


inline double G_co(double r, complex<double> xhat, complex<double> y // a
        , double rho) {                                  // rho
    return exp(-r * rho * cost(xhat)) * pow(W(y, xhat), 1 / (1 + rho));
}

inline double H_co(double r, complex<double> x, complex<double> y, double rho) {
    return exp(r * cost(x)) * pow(W(y, x), 1 / (1 + rho));
}

inline double H(double alpha, complex<double> x, complex<double> y, double rho) {
    //return exp(alpha(x)) * pow(W(y,x),1/(1+rho));
    return exp(alpha) * pow(W(y, x), 1 / (1 + rho));
}

void test() {
    MatrixXd a;
    a = MatrixXd::Zero(1, 1);
    MatrixXd b;
    b = MatrixXd::Zero(1, 1);

    a(0, 0) = 1000;
    b(0, 0) = -1000;
    cout << a.array().exp() << endl;
    cout << b.array().exp() << endl;
}

double fa(complex<double> x, complex<double> y, vector<double> alphas, double rho, int xind) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    double f = 0;
    double h = H(alphas[xind], x, y, rho);
    int xindex = 0;
    for (auto xhat: X) {
        f += Q(xindex) * G(alphas[xindex], xhat, y, rho) / h;
        xindex++;
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    fa_times.push_back(duration_XX);

    return f;
}

double fa_co(complex<double> x, complex<double> y, double r, double rho) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    double f = 0;
    double h = H_co(r, x, y, rho);
    int a = 0;
    for (auto xhat: X) {
        f += Q(a) * G_co(r, xhat, y, rho) / h; // todo check Q()
        a++;
    }
    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    fa_co_times.push_back(duration_XX);

    return f;
}


double E_0(double rho, vector<double> alphas, int n) {

    auto start_e0 = std::chrono::high_resolution_clock::now();

    /*
    cout << Q_mat.rows() << endl;
    cout << Q_mat.cols() << endl;
    cout << PI_mat.rows() << endl;
    cout << PI_mat.cols() << endl;
    cout << W_mat.rows() << endl;
    cout << W_mat.cols() << endl;
    */
    rho = 0; // todo temp

    MatrixXd W_firstpower = W_mat.array().pow(-(rho) / (1 + rho));
    MatrixXd W_secondpower = W_mat.array().pow(1 / (1 + rho));
    //MatrixXcd QW2 = ;
    //MatrixXcd QW2_transpose = QW2.transpose();

    //cout << endl << PI_mat << endl;

    cout << "Wf" << endl << W_firstpower << endl;
    cout << "Ws" << endl << W_secondpower << endl;
    cout << "test" << endl << (PI_mat.cwiseProduct(W_firstpower)) << endl;
    cout << "last" << endl << (Q_mat.array().transpose().pow(rho).matrix() * W_secondpower).transpose() << endl;

    VectorXd ones(n * n * sizeX);
    for (int i = 0; i < n * n * sizeX; i++) { ones(i) = 1; }

    double E0 = Q_mat.transpose() * // 1 x 32
                (PI_mat.cwiseProduct(W_firstpower)) * // 32 x 544
                ones;  // 1 x 32 x 32 x 544
    //(Q_mat.array().transpose() * W_secondpower).pow(rho).transpose();

    //MatrixXd ED = (D_mat*-0.5).array().exp();
    //MatrixXd Wpow = W_mat.array().pow(0.5);


    auto stop_e0 = std::chrono::high_resolution_clock::now();
    auto duration_e0 = std::chrono::duration_cast<std::chrono::microseconds>(stop_e0 - start_e0);

    //cout << endl << ED << endl;

    //double E0 = 0;

    e0_times.push_back(duration_e0);

    // todo change
    E0 = 0;
    return E0;
}

void printrowscols(MatrixXd m, string s) {
    //cout << s << " " << m.rows() << " " << m.cols() << endl;
}

/*
double E_0_1_co_old(){
    // has snr
    double sum = 0;
    for (complex<double> x1: X){
        for(complex<double> x2: X){
            sum += Q(x1) * Q(x2) * exp(-SNR/4 * abs_sq(x1-x2));
        }
    }
    return -log2(sum);
}
*/

double E_0_1_co_old() {
    // has snr
    double sum = 0;
    for (complex<double> x1: X) {
        for (complex<double> x2: X) {
            sum += Q(x1) * Q(x2) * exp(-1.0 / 4 * abs_sq(x1 - x2));
        }
    }
    return -log2(sum);
}

double E_0_1_co() {
    double sum = 0;
    cout << "SNR: " << SNR << endl;
    for (complex<double> x1: X) {
        for (complex<double> x2: X) {
            complex<double> mean = (x1 + x2) / 2.0;
            sum += Q(x1) * Q(x2) * exp(-SNR / 2.0 * (abs_sq(x1 - mean) + abs_sq(x2 - mean)));
        }
    }
    return -log2(sum);
}

double E_0_2_co() {
    // snr = 1
    double sum = 0;
    for (complex<double> x1: X) {
        for (complex<double> x2: X) {
            for (complex<double> x3: X) {
                complex<double> mean = (x1 + x2 + x3) / 3.0;
                sum += Q(x1) * Q(x2) * Q(x3) *
                       exp(-SNR / 3.0 * (abs_sq(x1 - mean) + abs_sq(x2 - mean) + abs_sq(x3 - mean)));
            }
        }
    }
    return -log2(sum);
}

double E_0_co(double r, double rho, double &grad_rho, double &grad_2_rho, double &E0, int n, vector<double> hweights,
              vector<double> multhweights, vector<double> roots) {
    // computes second der
    Eigen::VectorXd logqg2 = (Q_mat.transpose() * ((-1.0 / (1.0 + rho)) * D_mat.array()).exp().matrix()).array().log();
    Eigen::VectorXd qg2rho = (rho * logqg2.array()).exp();
    Eigen::MatrixXd pig1_mat = PI_mat.array() * ((rho / (1.0 + rho)) * D_mat.array()).exp();

    const int sizeX = Q_mat.size();
    const double s = 1.0 / (1.0 + rho);
    const double s_prime = -1.0 / pow(1.0 + rho, 2);
    const double s_double_prime = 2.0 / pow(1.0 + rho, 3);

    // Common terms -----------------------------------------------------------
    const MatrixXd ln_W = W_mat.array().log();
    const MatrixXd exp_slnW = (s * ln_W).array().exp();
    const MatrixXd exp_neg_srho_lnW = (-s * rho * ln_W).array().exp();

    // Frequently used terms ---------------------------------------------------
    const RowVectorXd QT_exp_slnW = Q_mat.transpose() * exp_slnW;
    const RowVectorXd QT_sprime_lnW_exp_slnW = Q_mat.transpose() *
                                               (s_prime * ln_W.array() * exp_slnW.array()).matrix();
    const RowVectorXd ratio_term = QT_sprime_lnW_exp_slnW.array() / QT_exp_slnW.array();

    // Compute values ----------------------------------------------------------
    // Value1
    MatrixXd term1 = (-s_prime * rho * ln_W - s * ln_W).array().square();
    RowVectorXd val1 = (Q_mat.transpose() * (PI_mat.array() * exp_neg_srho_lnW.array() * term1.array()).matrix())
                       * QT_exp_slnW.array().pow(rho).matrix().transpose();
    double value1 = val1.value();

    // Value2
    MatrixXd term2 = (-s_double_prime * rho * ln_W - 2.0 * s_prime * ln_W);
    RowVectorXd val2 = (Q_mat.transpose() * (PI_mat.array() * exp_neg_srho_lnW.array() * term2.array()).matrix())
                       * QT_exp_slnW.array().pow(rho).matrix().transpose();
    double value2 = val2.value();

    // Value3 - Corrected
    MatrixXd term3 = (-s_prime * rho * ln_W - s * ln_W);
    MatrixXd val3_left_part = (PI_mat.array() * exp_neg_srho_lnW.array() * term3.array());
    RowVectorXd val3_left = Q_mat.transpose() * val3_left_part;
    RowVectorXd val3_right = QT_exp_slnW.array().pow(rho) *
                             (QT_exp_slnW.array().log() + rho * ratio_term.array());
    double value3 = 2.0 * val3_left.cwiseProduct(val3_right).sum();

    // Value4
    RowVectorXd squared_term = (QT_exp_slnW.array().log() + rho * ratio_term.array()).square();
    RowVectorXd val4 = (Q_mat.transpose() * (PI_mat.array() * exp_neg_srho_lnW.array()).matrix())
                       * (QT_exp_slnW.array().pow(rho) * squared_term.array()).matrix().transpose();
    double value4 = val4.value();

    // Value5
    MatrixXd s_prime_sq_lnW_sq = s_prime * s_prime * ln_W.array().square();
    MatrixXd inner_term = s_double_prime * ln_W + s_prime_sq_lnW_sq;
    RowVectorXd term5 = 2.0 * ratio_term.array() +
                        rho * (Q_mat.transpose() * (inner_term.array() * exp_slnW.array()).matrix()).array() /
                        QT_exp_slnW.array() -
                        rho * ratio_term.array().square();

    RowVectorXd val5 = (Q_mat.transpose() * (PI_mat.array() * exp_neg_srho_lnW.array()).matrix())
                       * (QT_exp_slnW.array().pow(rho) * term5.array()).matrix().transpose();
    double value5 = val5.value();

    double m = (Q_mat.transpose() * pig1_mat * qg2rho).sum();
    double mp = (Q_mat.transpose() * pig1_mat * (qg2rho.array() * logqg2.array()).matrix()).sum()
                - (1.0 / (1.0 + rho)) *
                  (Q_mat.transpose() * (pig1_mat.array() * (-D_mat.array())).matrix() * qg2rho).sum();
    double m2p = value1 + value2 + value3 + value4 + value5;


    double F0 = m / PI;
    double Fder0 = mp / PI;
    double F2der0 = m2p / PI;

    grad_rho = -(Fder0) / (std::log(2) * F0);
    grad_2_rho = -(1.0 / std::log(2)) * ((F2der0 / F0) - std::pow(Fder0 / F0, 2));
    E0 = -log2(F0);

    return E0;
}

double E_0_co(double r, double rho, double &grad_rho, double &E0) {
    // does not compute second der
    Eigen::VectorXd logqg2 = (Q_mat.transpose() * ((-1.0 / (1.0 + rho)) * D_mat.array()).exp().matrix()).array().log();
    // Before qg2rho = exp(rho * logqg2):
    double max_log = logqg2.maxCoeff();
    double min_log = logqg2.minCoeff();
    //cout << "should print" << endl;
    if (abs(rho * max_log) > 700) { // exp(709) overflows double
        std::cout << "err1: Exponentiation overflow/underflow risk: " << rho * max_log << "\n";
    } else if (rho * min_log < -700) {

    }
    Eigen::VectorXd qg2rho = (rho * logqg2.array()).exp();
    Eigen::MatrixXd pig1_mat = PI_mat.array() * ((rho / (1.0 + rho)) * D_mat.array()).exp();

    // In E_0_co(), after computing D_mat:
    if (D_mat.hasNaN()) std::cout << "err2: NaN in D_mat!\n";
    if (D_mat.minCoeff() < 0) std::cout << "err3: Negative values in D_mat!\n";

    // After computing logqg2:
    if (logqg2.hasNaN()) std::cout << "err4: NaN in logqg2!\n";
    if (logqg2.minCoeff() == -std::numeric_limits<double>::infinity()) std::cout << "err5: -inf in logqg2!\n";
    //cout << "n: " << n << endl;
    //cout << "PI_mat size: " << PI_mat.rows() << " " << PI_mat.cols() << endl;
    //cout << PI_mat << endl;
    //cout << "D_mat  size: " << D_mat .rows() << " " << D_mat.cols() << endl;
    //cout << D_mat << endl;

    const int sizeX = Q_mat.size();
    const double s = 1.0 / (1.0 + rho);
    const double s_prime = -1.0 / pow(1.0 + rho, 2);

    double m = (Q_mat.transpose() * pig1_mat * qg2rho).sum();
    double mp = (Q_mat.transpose() * pig1_mat * (qg2rho.array() * logqg2.array()).matrix()).sum()
                - (1.0 / (1.0 + rho)) *
                  (Q_mat.transpose() * (pig1_mat.array() * (-D_mat.array())).matrix() * qg2rho).sum();

    // Before F0 = m/PI:
    if (std::abs(m) < 1e-300) std::cout << "err6: Near-zero m: " << m << "\n";
    if (std::abs(PI) < 1e-300) std::cout << "err7: Near-zero PI: " << PI << "\n";
    double F0 = m / PI;
    double Fder0 = mp / PI;

    grad_rho = -(Fder0) / (std::log(2) * F0);
    // After computing grad_rho:
    if (!std::isfinite(grad_rho)) {
        std::cout << "err8: Non-finite gradient: " << grad_rho
                  << " at rho=" << rho << " SNR=" << SNR << "\n";
    }
    E0 = -log2(F0);

    // DEBUG: Print key intermediates
    //std::cout << "\n==== Eigen Version ====\n";
    /*
    std::cout << "logqg2[0]: " << logqg2(0) << std::endl;
    std::cout << "qg2rho[0]: " << qg2rho(0) << std::endl;

    Eigen::VectorXd pig1_first_col = pig1_mat.col(0);
    std::cout << "pig1_mat(0,0): " << pig1_first_col(0) << std::endl;
    */
    /*
    std::cout << "m: " << m << " | mp: " << mp << std::endl;
    std::cout << "F0: " << F0 << " | Fder0: " << Fder0 << std::endl;
     */
    /*
    cout << "PI_mat: " << endl << PI_mat << endl;
    cout << "D_mat: " << endl << D_mat << endl;
    cout << "Q_mat: " << endl << Q_mat << endl;
    cout << "logqg2_mat: " << endl << logqg2 << endl;
    cout << "qg2rho_mat: " << endl << qg2rho << endl;
    cout << "pig1_mat: " << endl << pig1_mat << endl;
    */
    /*
    // In both functions:
    const int test_j = 1;
    const int test_i = 0;
    // Eigen Version:
    std::cout << "Eigen PI_mat(0,1): " << PI_mat(0, test_j) << std::endl;

      // In both versions:
    const int test_block = 1; // Second block (i=1)
    const int test_col = test_block * n*n + 0; // First column of second block
    const int test_row = 3;

    // Eigen
    std::cout << "Eigen PI(" << test_row << "," << test_col << "): "
              << PI_mat(test_row, test_col) << "\n";

    // Check D_mat(0, n*n) - first element of second block
    const int d_test_col = n*n;
    const int d_test_row = 5;

    // Eigen
    std::cout << "Eigen D(" << d_test_row << "," << d_test_col << "): "
              << D_mat(d_test_row, d_test_col) << "\n";

    // Check pig1_mat for column j=1, row i=0
    const int p_test_j = 3;
    const int p_test_i = 4;
    const int p_idx = p_test_j * sizeX + p_test_i;

    // Eigen
    std::cout << "Eigen pig1(" << p_test_i << "," << p_test_j << "): "
              << pig1_mat(p_test_i, p_test_j) << "\n";

    // Check contribution to `m` from column j=1
    const int m_test_j = 1;
    double m_contribution = 0.0;

    // Eigen
    Eigen::VectorXd pig1_col = pig1_mat.col(m_test_j);
    double eigen_sum_pig1 = (Q_mat.transpose() * pig1_col).sum();
    double eigen_temp = eigen_sum_pig1 * qg2rho[m_test_j];
    std::cout << "Eigen m contribution j=1: " << eigen_temp << "\n";

    // Check a high-D_mat value (e.g., j=256)
    const int ttest_j = 18;
    const int ttest_i = 20;
    const int idx = ttest_j * sizeX + ttest_i;

// Eigen
    std::cout << "Eigen pig1(" << ttest_i << "," << ttest_j << "): "
              << pig1_mat(ttest_i, ttest_j) << "\n";
    */
    return E0;
}

double E_0_co_vec(double r, double rho, double &grad_rho, double e0, int nn,
                  std::vector<double> hweights, std::vector<double> multhweights,
                  std::vector<double> roots,
                  const std::vector<double> &Q_mat,
                  const std::vector<double> &PI_mat,
                  const std::vector<double> &D_mat) {

    const int cols = n * n * sizeX;
    const double inv_1prho = 1.0 / (1.0 + rho);
    const double rho_over_1prho = rho * inv_1prho;

    // 1. Precompute logqg2 and qg2rho ------------------------------------------
    std::vector<double> logqg2(cols);
    std::vector<double> qg2rho(cols);

    for (int j = 0; j < cols; ++j) {
        double sum = 0.0;
        for (int i = 0; i < sizeX; ++i) {
            const int idx = j * sizeX + i;
            sum += Q_mat[i] * exp(-D_mat[idx] * inv_1prho);
        }
        logqg2[j] = log(sum);
        qg2rho[j] = exp(rho * logqg2[j]);
    }

    // 2. Precompute pig1_mat --------------------------------------------------
    std::vector<double> pig1_mat(sizeX * cols);
    for (int j = 0; j < cols; ++j) {
        for (int i = 0; i < sizeX; ++i) {
            const int idx = j * sizeX + i;
            // FIXED: Add parentheses around exponent argument
            pig1_mat[idx] = PI_mat[idx] * exp((rho / (1.0 + rho)) * D_mat[idx]);
        }
    }

    // 3. Compute m and mp -----------------------------------------------------
    double m = 0.0, term1_mp = 0.0, term2_mp = 0.0;

    for (int j = 0; j < cols; ++j) {
        double sum_pig1 = 0.0, sum_pig1_D = 0.0;

        for (int i = 0; i < sizeX; ++i) {
            const int idx = j * sizeX + i;
            const double Q_i = Q_mat[i];
            sum_pig1 += Q_i * pig1_mat[idx];
            sum_pig1_D += Q_i * pig1_mat[idx] * (-D_mat[idx]);
        }

        const double temp = sum_pig1 * qg2rho[j];
        m += temp;
        term1_mp += temp * logqg2[j];
        term2_mp += sum_pig1_D * qg2rho[j];
    }

    term2_mp *= inv_1prho;
    const double mp = term1_mp - term2_mp;


    // 4. Final calculations ---------------------------------------------------
    const double F0 = m / PI;
    const double Fder0 = mp / PI;
    grad_rho = -Fder0 / (std::log(2) * F0);
    e0 = -log2(F0);

    // DEBUG: Print same intermediates
    std::cout << "\n==== Vector Version ====\n";
    /*
    std::cout << "logqg2[0]: " << logqg2[0] << std::endl;
    std::cout << "qg2rho[0]: " << qg2rho[0] << std::endl;
    std::cout << "pig1_mat[0]: " << pig1_mat[0] << std::endl;
    */
    std::cout << "m: " << m << " | mp: " << mp << std::endl;
    std::cout << "F0: " << F0 << " | Fder0: " << Fder0 << std::endl;
    /*
    cout << "Q_mat:" << endl;
    for(int i = 0; i < Q_mat.size(); i++){ cout << Q_mat[i] << " "; }
    cout << endl;
    cout << "D_mat:" << endl;
    for(int i = 0; i < D_mat.size(); i++){ cout << D_mat[i] << " "; }
    cout << endl;
    cout << "PI_mat:" << endl;
    for(int i = 0; i < PI_mat.size(); i++){ cout << PI_mat[i] << " "; }
    cout << endl;
    cout << "logqg2_mat:" << endl;
    for(int i = 0; i < logqg2.size(); i++){ cout << logqg2[i] << " "; }
    cout << endl;

    cout << "qg2rho_mat:" << endl;
    for(int i = 0; i < qg2rho.size(); i++){ cout << qg2rho[i] << " "; }
    cout << endl;

    cout << "pig1_mat:" << endl;
    for(int i = 0; i < pig1_mat.size(); i++){ cout << pig1_mat[i] << " "; }
    cout << endl;
    */

/*
    const int test_idx = 1 * sizeX + 0;  // Column-major index for (row=0, col=1)
    std::cout << "Vector PI[1]: " << PI_mat[test_idx] << "\n";
    // In both versions:
    const int test_block = 1; // Second block (i=1)
    const int test_col = test_block * n*n + 0; // First column of second block
    const int test_row = 3;

    // Vector
    const int vec_idx = test_col * sizeX + test_row; // Column-major index
    std::cout << "Vector PI[" << vec_idx << "]: " << PI_mat[vec_idx] << "\n";

    // Check D_mat(0, n*n) - first element of second block
    const int d_test_col = n*n;
    const int d_test_row = 5;

    // Vector
    const int d_vec_idx = d_test_col * sizeX + d_test_row;
    std::cout << "Vector D[" << d_vec_idx << "]: " << D_mat[d_vec_idx] << "\n";

    // Check pig1_mat for column j=1, row i=0
    const int p_test_j = 3;
    const int p_test_i = 4;
    const int p_idx = p_test_j * sizeX + p_test_i;

    // Vector
    std::cout << "Vector pig1[" << p_idx << "]: " << pig1_mat[p_idx] << "\n";

    // Check contribution to `m` from column j=1
    const int m_test_j = 1;
    double m_contribution = 0.0;
    // Vector
    double vec_sum_pig1 = 0.0;
    for(int i = 0; i < sizeX; ++i) {
        const int idx = m_test_j * sizeX + i;
        vec_sum_pig1 += Q_mat[i] * pig1_mat[idx];
    }
    double vec_temp = vec_sum_pig1 * qg2rho[m_test_j];
    std::cout << "Vector m contribution j=1: " << vec_temp << "\n";

    // Check a high-D_mat value (e.g., j=256)
    const int ttest_j = 18;
    const int ttest_i = 20;
    const int idx = ttest_j * sizeX + ttest_i;

// Vector
    std::cout << "Vector pig1[" << idx << "]: " << pig1_mat[idx] << "\n";
    */
    return e0;
}

double E_0_co(double r, double rho, double &grad_rho, int n, vector<double> hweights, vector<double> multhweights,
              vector<double> roots) {
    // does not compute second der nor e0
    Eigen::VectorXd logqg2 = (Q_mat.transpose() * ((-1.0 / (1.0 + rho)) * D_mat.array()).exp().matrix()).array().log();
    Eigen::VectorXd qg2rho = (rho * logqg2.array()).exp();
    Eigen::MatrixXd pig1_mat = PI_mat.array() * ((rho / (1.0 + rho)) * D_mat.array()).exp();

    double m = (Q_mat.transpose() * pig1_mat * qg2rho).sum();
    double mp = (Q_mat.transpose() * pig1_mat * (qg2rho.array() * logqg2.array()).matrix()).sum()
                - (1.0 / (1.0 + rho)) *
                  (Q_mat.transpose() * (pig1_mat.array() * (-D_mat.array())).matrix() * qg2rho).sum();

    double F0 = m / PI;
    double Fder0 = mp / PI;

    grad_rho = -(Fder0) / (std::log(2) * F0);

    return 1; // todo change
}

inline void
gradient_f(complex<double> x, complex<double> y, vector<double> alphas, double rho, vector<double> &grads_alpha,
           double &grad_rho, int xindex) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < sizeX; i++) { grads_alpha[i] = 0; }
    grad_rho = 0;

    double h = H(alphas[xindex], x, y, rho), GHQ;
    complex<double> x_hat_hat;

    int xcounter = 0;
    for (auto xhat: X) {
        GHQ = Q(xcounter) * (G(alphas[xcounter], xhat, y, rho) / h);

        for (int c = 0; c < sizeX; c++) { // last alpha not updated
            double aux = 0;
            x_hat_hat = X[c];

            if (xhat == x_hat_hat) {
                aux -= rho;
            }

            if (x == x_hat_hat) {
                aux -= 1;
            }

            grads_alpha[c] += GHQ * aux;
        }

        grad_rho += GHQ * (-alphas[xcounter]/* - 1/pow(1+rho,2)*log(W(y,xhat))+1/pow(1+rho,2)*log(W(y,x))*/);
        xcounter++;
    }
    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    gradient_f_times.push_back(duration_XX);
}

inline void
gradient_f_co(complex<double> x, complex<double> y, double r, double rho, double &grad_r, double &grad_rho) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    grad_rho = 0;
    grad_r = 0;

    double h = H_co(r, x, y, rho), GHQ;
    int a = 0;
    for (auto xhat: X) {
        double g = G_co(r, xhat, y, rho);
        GHQ = Q(a) * (g / h);

        grad_rho += GHQ * (-r * cost(xhat)/*-1/((1+rho)*(1+rho)) * (loG_co(wyx) - loG_co(W(y,xhat)))*/);

        double c1 = cost(xhat);
        double c2 = cost(x);
        grad_r += GHQ * (-rho * c1 - c2);
        a++;
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    gradient_f_co_times.push_back(duration_XX);
}


double e02(int n) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    double lhs = 0, rhs = 0, mylog, num_log, qx, wij;
    complex<double> y;
    int m = n;
    vector<double> roots = Hroots(n);
    vector<double> hweights = all_hweights[n];

    int xcounter = 0;
    for (auto x: X) {
        qx = Q(xcounter);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                complex<double> root(roots[i], roots[j]); // wi + imag*wj;
                y = sqrt(SNR) * x + root;
                wij = hweights[j] * hweights[i]; //wi * wj

                num_log = 0;
                int a = 0;
                for (auto xhat: X) {
                    float q = Q(a);
                    double w = W(y, xhat);
                    num_log += q * w;
                    a++;
                }
                mylog = log2(num_log / W(y, x));

                rhs += qx * mylog * wij * 1 / PI;
                lhs += qx * mylog * mylog * wij * 1 / PI;
            }
        }
        xcounter++;
    }

    double out = (rhs * rhs - lhs) * log(2);

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    e02_times.push_back(duration_XX);

    return out;
}

inline void gradient_e0(vector<double> alphas, double rho, vector<double> &grads_alpha, double &grad_rho, int my_n,
                        vector<double> hweights, vector<double> mult, vector<double> roots) { // TODO optimize
    // ---------------------------
    // | GRADIENT OF E_0 - rho*R |
    // ---------------------------

    auto start_XX = std::chrono::high_resolution_clock::now();

    double grad_f_rho;
    vector<double> grad_f_alphas(sizeX);
    double denominator = 0, numerator_rho = 0, hwij, hi, aa_f_a_rho;
    vector<double> numerator_alphas(sizeX);

    double Aa, f_a;
    complex<double> y;
    // fa
    for (int i = 0; i < my_n; i++) { //todo change multsize
        hi = hweights[i];
        for (int j = 0; j < my_n; j++) {
            hwij = hi * hweights[j];
            complex<double> root(roots[i], roots[j]);
            int xcounter = 0;
            for (auto x: X) {
                Aa = 1 / PI * Q(xcounter) * hwij;
                y = std::sqrt(SNR) * x + root;
                gradient_f(x, y, alphas, rho, grad_f_alphas, grad_f_rho,
                           xcounter); //para cada f(x,...) tenemos derivadas alpha(x_hat_hat)
                f_a = fa(x, y, alphas, rho, xcounter);
                denominator += Aa * std::pow(f_a, rho);
                numerator_rho += Aa * std::pow(f_a, rho) * (log(f_a) + rho * grad_f_rho / f_a);
                for (int c = 0; c < sizeX; c++) {
                    numerator_alphas[c] += Aa * rho * std::pow(f_a, rho - 1) * grad_f_alphas[c];
                }
                xcounter++;
            }
        }
    }
    grad_rho = -std::log2(eu) * numerator_rho / denominator - R;
    for (int c = 0; c < sizeX - 1; c++) { // last alpha not updated
        grads_alpha[c] = (-std::log2(eu) * numerator_alphas[c] / denominator) +
                         (-std::log2(eu) * numerator_alphas[sizeX - 1] / denominator) * (-Q(c) / Q(sizeX - 1));
    }


    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    gradient_e0_times.push_back(duration_XX);
}


inline void gradient_e0_co(double r, double rho, double &grad_r, double &grad_rho, int my_n, vector<double> hweights,
                           vector<double> mult, vector<double> roots) { // TODO optimize
    // ---------------------------
    // | GRADIENT OF E_0 - rho*R |
    // ---------------------------

    auto start_XX = std::chrono::high_resolution_clock::now();

    double grad_f_r, grad_f_rho;
    double numerator_r = 0, denominator = 0, numerator_rho = 0, hwij, hi, aa_f_a_rho;

    vector<chrono::microseconds> inner_times;

    double Aa, f_a;
    complex<double> y;
    // fa
    for (int i = 0; i < my_n; i++) { // todo change multsize
        hi = hweights[i];
        for (int j = 0; j < my_n; j++) {
            hwij = hi * hweights[j];
            complex<double> root(roots[i], roots[j]);
            int a = 0;
            for (auto x: X) {
                Aa = 1 / PI * Q(a) * hwij;
                y = std::sqrt(SNR) * x + root;

                auto start_inner = std::chrono::high_resolution_clock::now();

                gradient_f_co(x, y, r, rho, grad_f_r, grad_f_rho); //todo problems in the past
                f_a = fa_co(x, y, r, rho);

                auto stop_inner = std::chrono::high_resolution_clock::now();
                auto duration_inner = std::chrono::duration_cast<std::chrono::microseconds>(stop_inner - start_inner);

                inner_times.push_back(duration_inner);

                aa_f_a_rho = Aa * std::pow(f_a, rho);
                numerator_r += Aa * rho * std::pow(f_a, rho - 1) * grad_f_r;
                denominator += aa_f_a_rho;
                numerator_rho += aa_f_a_rho * (std::log(f_a) + rho * grad_f_rho / f_a);
                a++;
            }
        }
    }

    grad_r = -std::log2(eu) * numerator_r / denominator;
    grad_rho = -std::log2(eu) * numerator_rho / denominator - R;

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    gradient_e0_co_times.push_back(duration_XX - sum_(inner_times));
}


inline vector<double> mult_newhweights(vector<double> hweights, int my_n) {
    // we only pick the most significant hweights, those inside the real-imaginary circle, and pairwise multiply and store them.

    auto start_XX = std::chrono::high_resolution_clock::now();

    sort(hweights.begin(), hweights.end());
    double boundary = hweights[my_n - 1] - hweights[0];
    double mult, hi;
    vector<double> newhweights;

    int multsize = 0;
    for (int i = 0; i < my_n; i++) {
        hi = hweights[i];
        for (int j = 0; j < my_n; j++) {
            mult = hi * hweights[j];
            if (mult <= boundary) {
                newhweights.push_back(mult);
                multsize++;
            }
        }
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    mult_newhweights_times.push_back(duration_XX);

    return newhweights;
}


void compute_hweights(int n, int num_iterations) {
    /*
     * PRECOMPUTES THE WEIGHTS, ROOTS AND THE MULTIPLICATION OF WEIGHTS
     */
    //initQ();
    auto start_XX = std::chrono::high_resolution_clock::now();

    if (DEBUG) {
        cout << endl;
        cout << setw(4) << left << "it";
        cout << setw(10) << left << "rho";
        cout << setw(10) << left << "r";
        cout << setw(13) << left << "-e0+rho*r";
        cout << setw(13) << left << "-d_rho";
        cout << setw(13) << left << "d_r";
        cout << setw(3) << left << "N";
        cout << endl;
    }

    int my_n;
    low = n; // todo temp

    my_n = n;
    all_hweights[my_n] = Hweights(my_n - 1);
    all_roots[my_n] = Hroots(my_n);
    all_multhweights[my_n] = mult_newhweights(all_hweights[my_n], my_n);

    /*
    double increment = (n-low)/num_iterations;

    int prev_n = -1;
    vector<double> hweights, roots, multhweights;
    double msum;

    for (int i = 0; i < num_iterations; ++i) {
        msum = 0;

        my_n = ceil(low + increment*i);
        if(my_n != prev_n){
            all_hweights[my_n]     = Hweights(my_n-1);
            all_roots[my_n]        = Hroots(my_n);
            all_multhweights[my_n] = mult_newhweights(all_hweights[my_n], my_n);
        }
        prev_n = my_n;
    }
     */
    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    compute_hweights_times.push_back(duration_XX);
}

// Gradient Descent of E0
double GD_ccomp(vector<double> &alphas, double &rho, double learning_rate, int num_iterations, int n) {
    //initQ();

    auto start_XX = std::chrono::high_resolution_clock::now();

    float error = 0.05;

    if (DEBUG) {
        cout << endl;
        cout << setw(4) << left << "it";
        cout << setw(10) << left << "rho";
        for (int c = 0; c < sizeX; c++) {
            cout << setw(10) << left << "alpha" + to_string(c + 1);
        }
        cout << setw(13) << left << "-e0+rho*r";
        cout << setw(13) << left << "-d_rho";
        for (int c = 0; c < sizeX; c++) {
            cout << setw(13) << left << "d_alpha" + to_string(c + 1);
        }
        cout << setw(3) << left << "N";
        cout << endl;
    }

    int my_n;

    double increment = (n - low) / num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;
    double msum;
    /*
    if(DEBUG) {
        cout << "rho: " << rho << endl;
        for(auto x: alphas){
            cout << "alpha: " << x << " ";
        }
        cout << endl;
    }
    */

    double grad_rho = 0, grad_lambda;
    vector<double> grad_alphas(sizeX);

    for (int i = 0; i < num_iterations; ++i) {
        msum = 0;

        my_n = ceil(low + increment * i);

        // todo put out
        if (my_n != prev_n) {
            hweights = all_hweights[my_n];
            roots = all_roots[my_n];
            multhweights = all_multhweights[my_n];
        }

        prev_n = my_n;

        gradient_e0(alphas, rho, grad_alphas, grad_rho, my_n - 1, hweights, multhweights, roots);

        // update alphas
        for (int c = 0; c < sizeX - 1; c++) { // alphas from 0 to |X|-1
            alphas[c] += 0.1 * grad_alphas[c];
            msum += Q(c) * alphas[c];
        }
        alphas[sizeX - 1] = -1 / Q(sizeX - 1) * msum; // alpha(|X|)

        // update rho
        rho += learning_rate * grad_rho;
        if (rho <= 0) rho = 0.00000001; else if (rho >= 1) rho = 0.99999999; // todo revise

        bool alphasder = true;
        //if(i >= 1){
        for (int p = 0; p < sizeX - 2; p++) {
            if (grad_alphas[p] >= error || grad_alphas[p] <= -error) {
                alphasder = false;
                break;
            }
        }

        if (alphasder) {
            if (rho == 0.00000001 || rho == 0.99999999 || grad_rho <= error && grad_rho >= -error) {
                if (DEBUG) {
                    cout << endl;
                    double e0 = E_0(rho, alphas, n) - rho * R;
                    cout << endl;
                    cout << setw(4) << left << i;
                    cout << setw(10) << left << setprecision(6) << rho;
                    for (int c = 0; c < sizeX; c++) {
                        cout << setw(10) << left << setprecision(3) << alphas[c] << " ";
                    }
                    cout << setw(13) << left << setprecision(6) << e0;
                    cout << setw(13) << left << setprecision(6) << grad_rho;
                    for (int c = 0; c < sizeX; c++) {
                        cout << setw(13) << left << setprecision(3) << grad_alphas[c] << " ";
                    }
                    cout << setw(3) << left << my_n;
                    cout << " ";
                    cout << endl;
                }
                //qDebug() << i;
                return E_0(rho, alphas, n) - rho * R;
            }
        }

        //}
        if (DEBUG) {
            cout << endl;
            cout << setw(4) << left << i;
            cout << setw(10) << left << setprecision(6) << rho;
            for (int c = 0; c < sizeX; c++) {
                cout << setw(10) << left << setprecision(3) << alphas[c] << " ";
            }
            cout << setw(13) << left << setprecision(6) << E_0(rho, alphas, n) - rho * R;
            cout << setw(13) << left << setprecision(6) << grad_rho;
            for (int c = 0; c < sizeX; c++) {
                cout << setw(13) << left << setprecision(3) << grad_alphas[c] << " ";
            }
            cout << setw(3) << left << my_n;
            cout << " ";
            cout << endl;
            //qDebug() << num_iterations;
        }
    }
    double out = E_0(rho, alphas, n) - rho * R;

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    GD_ccomp_times.push_back(duration_XX);
    //cout << num_iterations << endl;
    return out;
}

double initial_guess(double r, double E0_0, double E0_1, double E0_0_der, double E0_1_der, double &max_g) {
    // Compute G and its derivatives at rho=0 and rho=1
    const double A = E0_0;
    const double B = E0_0_der - r;
    const double C = E0_1 - r;
    const double D = E0_1_der - r;

    // Cubic coefficients for G(rho) = a + b*rho + c*rho^2 + d*rho^3
    const double a = A;
    const double b = B;
    const double c = 3 * (C - A) - 2 * B - D;
    const double d = -2 * (C - A) + B + D;

    // Coefficients for the derivative G'(rho) = b + 2c*rho + 3d*rho^2
    const double a_quad = 3 * d;
    const double b_quad = 2 * c;
    const double c_quad = b;

    std::vector<double> roots;

    // Solve quadratic equation: a_quad*rho^2 + b_quad*rho + c_quad = 0
    if (std::abs(a_quad) > 1e-10) { // Quadratic case
        const double discriminant = b_quad * b_quad - 4 * a_quad * c_quad;
        if (discriminant >= 0) {
            const double sqrt_disc = std::sqrt(discriminant);
            const double root1 = (-b_quad + sqrt_disc) / (2 * a_quad);
            const double root2 = (-b_quad - sqrt_disc) / (2 * a_quad);

            if (root1 >= 0.0 && root1 <= 1.0) {
                roots.push_back(root1);
            }
            if (root2 >= 0.0 && root2 <= 1.0 && root2 != root1) {
                roots.push_back(root2);
            }
        }
    } else { // Linear case: a_quad is approximately zero
        if (std::abs(b_quad) > 1e-10) {
            const double root = -c_quad / b_quad;
            if (root >= 0.0 && root <= 1.0) {
                roots.push_back(root);
            }
        }
    }

    // Collect candidate points: 0, 1, and valid roots
    std::vector<double> candidates = {0.0, 1.0};
    for (const double root: roots) {
        candidates.push_back(root);
    }

    // Evaluate G(rho) at all candidates and find the maximum
    max_g = -std::numeric_limits<double>::infinity();
    double best_rho = 0.0;

    for (const double rho: candidates) {
        const double g = a + b * rho + c * rho * rho + d * rho * rho * rho;
        if (g > max_g) {
            max_g = g;
            best_rho = rho;
        }
    }

    return best_rho;
}

// Convert Eigen matrix to column-major vector
std::vector<double> eigenToColumnMajor(const Eigen::MatrixXd &mat) {
    std::vector<double> vec(mat.size());
    for (int col = 0; col < mat.cols(); ++col) {
        for (int row = 0; row < mat.rows(); ++row) {
            vec[col * mat.rows() + row] = mat(row, col);
        }
    }
    return vec;
}

// Convert Eigen matrices to row-major vectors
std::vector<double> eigenToRowMajor(const Eigen::MatrixXd &mat) {
    std::vector<double> vec(mat.size());
    for (int row = 0; row < mat.rows(); ++row) {
        for (int col = 0; col < mat.cols(); ++col) {
            vec[row * mat.cols() + col] = mat(row, col);
        }
    }
    return vec;
}

double GD_co(double &r, double &rho, double &rho_interpolated, int num_iterations, int n, bool updateR) {
    // Gradient Descent of E0

    auto start_XX = std::chrono::high_resolution_clock::now();

    //if (DEBUG) cout  << "i rho e0 e0-rho*R grad_rho " << endl;

    //float error = 0.00000000001;
    float error = 10E-10;

    int my_n;

    double increment = (n - low) / num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;
    double e0;
    double grad_r, grad_rho, grad_2_rho;
    double nextrho, auxrho = rho, nextauxrho;
    double nextr, auxr = rho, nextauxr;
    vms inner_times;

    hweights = all_hweights[n];
    roots = all_roots[n];
    multhweights = all_multhweights[n];


    E_0_co(R, 0, grad_rho, e0);
    double E0_0 = e0, E0_prime_0 = grad_rho;

    E_0_co(R, 1, grad_rho, e0);
    double E0_1 = e0, E0_prime_1 = grad_rho;

    double max_g;
    rho = initial_guess(R, E0_0, E0_1, E0_prime_0, E0_prime_1, max_g);
    //cout << "rho ig: " << rho << endl;

    rho_interpolated = rho;

    if (rho <= 0 || rho >= 1) return E_0_co(R, rho, grad_rho, e0);

    E_0_co(R, rho + 0.0000001, grad_rho, e0);
    double E0_prime_guess_plus = grad_rho;

    E_0_co(R, rho, grad_rho, e0);
    double E0_prime_guess = grad_rho;

    // si e0'(rho)-r s positiva del punt fins a 1, si s neg de 0 al punt
    /*
    double g_rho = grad_rho-r;

    if(g_rho <= 0){
        cout << "cas1" << endl;
        E_0_co(r, rho, grad_rho, e0);
        E0_prime_1 = grad_rho;
        //E0_second_prime_0 is at rho=0
    }
    else if(g_rho >= 0){
        cout << "cas2" << endl;
        E_0_co(r, rho, grad_rho, grad_2_rho,e0, my_n-1, hweights, multhweights, roots);
        E0_prime_0 = grad_rho;
        E0_second_prime_0 = grad_2_rho;
    }
    */

    //cout << "grad_2_guess: " << grad_2_guess << endl;

    double grad_2_guess = ((E0_prime_guess_plus - E0_prime_guess) / (0.0000001));
    double L = (-grad_2_guess);
    double learning_rate = 1 / L;

    for (int i = 0; i < num_iterations; ++i) {
        //cout << "lr: " << fixed << setprecision(16) << learning_rate << endl;
        /*
        std::vector<double> Q_v(Q_mat.data(), Q_mat.data() + Q_mat.size());
        std::vector<double> PI_v(PI_mat.data(), PI_mat.data() + PI_mat.size());
        std::vector<double> D_v(D_mat.data(), D_mat.data() + D_mat.size());
        */
        /*
        std::vector<double> Q_v = eigenToColumnMajor(Q_mat);
        std::vector<double> PI_v = eigenToColumnMajor(PI_mat);
        std::vector<double> D_v = eigenToColumnMajor(D_mat);

        auto start_e0 = std::chrono::high_resolution_clock::now();
        E_0_co_vec(0.5, rho, grad_rho, e0, my_n-1, hweights, multhweights, roots, Q_v, PI_v, D_v);
        auto stop_e0 = std::chrono::high_resolution_clock::now();
        auto duration_e0 = std::chrono::duration_cast<std::chrono::microseconds>(stop_e0 - start_e0);
        cout << "duration_e0: " << duration_e0.count() << endl;
        */
        auto start_e0 = std::chrono::high_resolution_clock::now();
        E_0_co(r, rho, grad_rho, e0); // todo: 0.5
        auto stop_e0 = std::chrono::high_resolution_clock::now();
        auto duration_e0 = std::chrono::duration_cast<std::chrono::microseconds>(stop_e0 - start_e0);
        cout << "duration_e0: " << duration_e0.count() << endl;

        grad_rho -= R;
        grad_rho = -grad_rho;
        grad_r = -grad_r;

        rho -= learning_rate * grad_rho;

        if (grad_rho <= error && grad_rho >= -error) {
            auto stop_XX = std::chrono::high_resolution_clock::now();
            auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
            //NAG_co_times.push_back(duration_XX - sum_(inner_times));
            cout << "NAG duration: " << duration_XX.count() << endl;
            rho = max(0.0, min(rho, 1.0)); // todo change
            return e0 - rho * R;
        }
        cout << fixed << setprecision(17) << i << " " << rho << " " << e0 << " " << e0 - rho * R << " " << grad_rho
             << endl;
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    //GD_co_times.push_back(duration_XX - sum_(inner_times));
    cout << "GD duration: " << duration_XX.count() << endl;
    rho = max(0.0, min(rho, 1.0)); // todo change
    return e0 - rho * R;
}
/*
double GD_co(double& r, double& rho, double learning_rate, int num_iterations, int n, bool updateR) {
    auto start_XX = std::chrono::high_resolution_clock::now();

    if (DEBUG) cout  << "it |  rho   |  r  |-e0+rho*r| -grad_rho| -grad_r" << endl;

    //float error = 0.00000000001;
    float error = 0.0000001;

    int my_n;

    double increment = (n-low)/num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;
    double e0;
    double grad_r, grad_rho, grad_2_rho;
    double nextrho, auxrho = rho, nextauxrho;
    double nextr, auxr = rho, nextauxr;
    vms inner_times;

    // vector<double> rhos = {0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1};

    for (int i = 0; i < num_iterations; ++i) {

        my_n = ceil(low + increment*i);

        if(my_n != prev_n){
            //free(&hweights); free(&roots); free(&multhweights);
            hweights = all_hweights[my_n];
            roots = all_roots[my_n];
            multhweights = all_multhweights[my_n];
        }

        prev_n = my_n;

        auto start_inner2 = std::chrono::high_resolution_clock::now();

        E_0_co(0.5, rho, grad_rho, grad_2_rho, e0, my_n-1, hweights, multhweights, roots);
        grad_rho -= R;


        auto stop_inner2 = std::chrono::high_resolution_clock::now();
        auto duration_inner2 = std::chrono::duration_cast<std::chrono::microseconds>(stop_inner2 - start_inner2);
        inner_times.push_back(duration_inner2);

        grad_rho = -grad_rho;
        grad_r = -grad_r;


        rho -= learning_rate * grad_rho;
        //if (rho <= 0) rho = 0.00000001; else if (rho >= 1) rho = 0.99999999;
        //rho += grad_rho;
        if(rho <= -1) rho = -1;
        if(rho >= 2) rho = 2;

        if(grad_rho <= error && grad_rho >= -error){
            auto stop_XX = std::chrono::high_resolution_clock::now();
            auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
            //NAG_co_times.push_back(duration_XX - sum_(inner_times));
            cout << "duration: " << duration_XX.count() << endl;
            return e0 - rho*R;
        }
        cout << fixed <<   setprecision(17) << i << " " << rho << " " << e0 << " " << e0-rho*R << " " << grad_rho << endl;
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    //GD_co_times.push_back(duration_XX - sum_(inner_times));
    cout << "duration: " << duration_XX.count() << endl;
    return e0 - rho*R;

}
*/


// Newton's Method of E0

double NM_co(double &r, double &rho, int num_iterations, int n, bool updateR) {
    auto start_XX = std::chrono::high_resolution_clock::now();

    if (DEBUG) {
        for (int i = 0; i < 60; i++) cout << "/";
        cout << endl;
        cout << setw(4) << left << "it";
        cout << setw(10) << left << "rho";
        cout << setw(10) << left << "r";
        cout << setw(13) << left << "-e0+rho*r";
        cout << setw(13) << left << "-d_rho";
        cout << setw(13) << left << "-d_2_rho";
        cout << endl;
    }

    float error = 10E-10;

    int my_n;

    double increment = (n - low) / num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;
    double e0;
    double grad_rho, grad_2_rho;
    double nextrho, auxrho = rho, nextauxrho;
    double nextr, auxr = rho, nextauxr;
    vms inner_times;

    // vector<double> rhos = {0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1};

    double E0_0, E0_1;
    double E0_prime_0;
    double E0_prime_1;
    double E0_double_prime_0;
    double E0_double_prime_1;
    double E0_minus1;
    E_0_co(r, 0, grad_rho, grad_2_rho, e0, my_n - 1, hweights, multhweights, roots);
    E0_0 = e0;
    E0_prime_0 = grad_rho;
    E0_double_prime_0 = grad_2_rho;
    E_0_co(r, 1, grad_rho, grad_2_rho, e0, my_n - 1, hweights, multhweights, roots);
    E0_1 = e0;
    E0_prime_1 = grad_rho;
    E0_double_prime_1 = grad_2_rho;
    E_0_co(r, -0.999, grad_rho, grad_2_rho, e0, my_n - 1, hweights, multhweights, roots);
    E0_minus1 = e0;

    //cout << E0_minus1 << " " << E0_0 << " " << E0_1 << " " << E0_prime_0 << " " << E0_prime_1 << " " << E0_double_prime_0 << " " << E0_double_prime_1 << endl;
    cout << E0_double_prime_0 << " " << E0_double_prime_1 << endl;

    double max_g;
    rho = initial_guess(r, E0_0, E0_1, E0_prime_0, E0_prime_1, max_g);
    //cout << "rho ig: " << rho << endl;

    for (int i = 0; i < num_iterations; ++i) {

        my_n = ceil(low + increment * i);

        if (my_n != prev_n) {
            //free(&hweights); free(&roots); free(&multhweights);
            hweights = all_hweights[my_n];
            roots = all_roots[my_n];
            multhweights = all_multhweights[my_n];
        }

        prev_n = my_n;
        auto start_inner2 = std::chrono::high_resolution_clock::now();
        double auxrho = rho;

        if (true && i == -1) {
            /*
            E_0_co(r, 0, grad_rho, grad_2_rho, e0, my_n-1, hweights, multhweights, roots);
            double grad_rho_at_0 = grad_rho;
            cout << "e0: " << e0 << endl;
            cout << "e0-rho*R: " << e0-rho*r << endl;
            cout << "gr0: " << grad_rho_at_0 << endl;
            cout << "gr_2_0: " << grad_2_rho << endl;

            E_0_co(r, 1, grad_rho, grad_2_rho, e0, my_n-1, hweights, multhweights, roots);
            double grad_rho_at_1 = grad_rho;
            cout << "e0: " << e0 << endl;
            cout << "e0-rho*R: " << e0-rho*r << endl;
            cout << "gr1: " << grad_rho_at_1 << endl;
            cout << "gr_2_1: " << grad_2_rho << endl;
            */
            for (double auxrho = 0; auxrho <= 1; auxrho += 0.01) {
                E_0_co(r, auxrho, grad_rho, grad_2_rho, e0, my_n - 1, hweights, multhweights, roots);
                cout << auxrho << " " << e0 - auxrho * r << endl;
                //cout << "gr_2: " << grad_2_rho << endl;
            }
        }


        E_0_co(r, rho, grad_rho, grad_2_rho, e0, my_n - 1, hweights, multhweights, roots);
        grad_rho -= r; //todo: R


        auto stop_inner2 = std::chrono::high_resolution_clock::now();
        auto duration_inner2 = std::chrono::duration_cast<std::chrono::microseconds>(stop_inner2 - start_inner2);
        inner_times.push_back(duration_inner2);


        grad_rho = -grad_rho;
        grad_2_rho = -grad_2_rho;

        if (fabs(grad_2_rho) < 1e-9) {
            cout << "Second derivative near zero; exiting." << endl;
            break;
        }

        if (DEBUG && i == 0) {
            cout << setw(4) << left << 0;
            cout << setw(10) << left << rho;
            cout << setw(10) << left << r;
            cout << setw(13) << left << e0 - rho * r;
            cout << setw(13) << left << grad_rho;
            cout << setw(13) << left << grad_2_rho;
            cout << endl;
        }

        nextrho = rho - grad_rho / grad_2_rho;

        // todo change for debug/some tests
        /*
        if (nextrho <= 0) nextrho = 0;
        if (nextrho >= 1) nextrho = 1;
*/
        rho = nextrho;

        if (grad_rho <= error && grad_rho >= -error) {
            //if(fabs(grad_rho / grad_2_rho) <= error){
            auto stop_XX = std::chrono::high_resolution_clock::now();
            auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
            //NAG_co_times.push_back(duration_XX - sum_(inner_times));
            if (DEBUG) {
                cout << setw(4) << left << i + 1;
                cout << setw(10) << left << rho;
                cout << setw(10) << left << r;
                cout << setw(13) << left << e0 - rho * r;
                cout << setw(13) << left << grad_rho;
                cout << setw(13) << left << grad_2_rho;
                cout << endl;
                for (int i = 0; i < 60; i++) cout << "/";
                cout << endl;
            }
            for (int i = 0; i < 60; i++) cout << "/";
            cout << endl;
            cout << "NM duration: " << duration_XX.count() << endl;
            for (int i = 0; i < 60; i++) cout << "/";
            cout << endl;
            return e0 - rho * r;
        }
        if (DEBUG) {
            cout << setw(4) << left << i + 1;
            cout << setw(10) << left << rho;
            cout << setw(10) << left << r;
            cout << setw(13) << left << e0 - rho * r;
            cout << setw(13) << left << grad_rho;
            cout << setw(13) << left << grad_2_rho;
            cout << endl;
        }
    }

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    //GD_co_times.push_back(duration_XX - sum_(inner_times));
    cout << "NM duration: " << duration_XX.count() << endl;
    return e0 - rho * R;

}


double GD_iid(double &r, double &rho, double &rho_interploated, int num_iterations, int n) {
    auto start_NAG_iid = std::chrono::high_resolution_clock::now();
    //cout << endl << "cooking" << endl;
    double out = GD_co(r, rho, rho_interploated, num_iterations, n, false);

    auto stop_NAG_iid = std::chrono::high_resolution_clock::now();
    auto duration_NAG_iid = std::chrono::duration_cast<std::chrono::microseconds>(stop_NAG_iid - start_NAG_iid);
    NAG_iid_times.push_back(chrono::microseconds(0));

    return out;
}


/*
double GD_cc(double& r, double& rho, double learning_rate, int num_iterations, int n){
    auto start_XX = std::chrono::high_resolution_clock::now();

    double out = GD_co(r, rho, learning_rate, num_iterations, n, true);

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    GD_cc_times.push_back(duration_XX);

    return out;
}
*/
void NAG_update(double &x_t, double &y_t, double &x_tp1, double &y_tp1, double beta, double grad, double kaux) {
    // updates the approximation using Nesterov Accelerated Gradient

    y_tp1 = x_t - beta * grad;
    x_tp1 = (1 + kaux) * y_tp1 - kaux * y_t;

    x_t = x_tp1;
    y_t = y_tp1;
}

double NAG(vector<double> &alphas, double &rho, int num_iterations, double beta, double k, int n) {

    auto start_NAG = std::chrono::high_resolution_clock::now();

    double kaux = ((sqrt(k) - 1) / (sqrt(k) + 1));
    vector<double> x_t_r = alphas, y_t_r = alphas, y_tp1_r(sizeX), x_tp1_r(sizeX);
    double x_t_rho = rho, y_t_rho = rho, y_tp1_rho, x_tp1_rho;
    double grad_rho;
    vector<double> grads_alpha(sizeX);
    if (DEBUG) cout << "it |  rho   |  r  |-e0+rho*r| -grad_rho| -grad_r" << endl;

    int my_n = n;
    double increment = (n - low) / num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;

    for (int i = 0; i < num_iterations; ++i) {

        my_n = ceil(low + increment * i);

        if (my_n != prev_n) {
            hweights = all_hweights[my_n];
            roots = all_roots[my_n];
            multhweights = all_multhweights[my_n];
        }

        prev_n = my_n;

        //grad_rho was nan in gradient_e0()
        gradient_e0(x_t_r, x_t_rho, grads_alpha, grad_rho, my_n - 1, hweights, multhweights, roots);
        for (int c = 0; c < sizeX; c++) grads_alpha[c] = -grads_alpha[c];
        grad_rho = -grad_rho;

        for (int c = 0; c < sizeX; c++)
            NAG_update(x_t_r[c], y_t_r[c], x_tp1_r[c], y_tp1_r[c], beta, grads_alpha[c], kaux);
        NAG_update(x_t_rho, y_t_rho, x_tp1_rho, y_tp1_rho, beta, grad_rho, kaux);

        if (DEBUG) {
            cout << fixed << setprecision(6) << i << " " << x_t_rho;
            for (int c = 0; c < sizeX; c++) cout << " " << x_t_r[c] << " ";
            cout << E_0(x_t_rho, x_t_r, n) - x_t_rho * R << " " << -grad_rho << " ";
            for (int c = 0; c < sizeX; c++) cout << " " << -grads_alpha[c] << " ";
            cout << endl;
        }
    }
    double out = E_0(x_t_rho, x_t_r, n) - x_t_rho * R;

    auto stop_NAG = std::chrono::high_resolution_clock::now();
    auto duration_NAG = std::chrono::duration_cast<std::chrono::microseconds>(stop_NAG - start_NAG);
    NAG_times.push_back(duration_NAG);

    return out;
}

double NAG_co(double &r, double &rho, double learning_rate, int num_iterations, int n, double k, bool updateR) {

    auto start_XX = std::chrono::high_resolution_clock::now();

    if (DEBUG) cout << "it |  rho   |  r  |-e0+rho*r| -grad_rho| -grad_r" << endl;

    //float error = 0.00000000001;
    float error = 0.0000001;

    int my_n;

    double increment = (n - low) / num_iterations;

    int prev_n = -1;
    vector<double> hweights;
    vector<double> roots;
    vector<double> multhweights;
    double e0;
    double grad_r, grad_rho, grad_2_rho;
    double nextrho, auxrho = rho, nextauxrho;
    double nextr, auxr = rho, nextauxr;
    vms inner_times;

    hweights = all_hweights[n];
    roots = all_roots[n];
    multhweights = all_multhweights[n];


    E_0_co(r, 0, grad_rho, e0);
    double E0_0 = e0;
    double E0_prime_0 = grad_rho;

    //cout << "der2_0: " << E0_prime_0 << endl;

    E_0_co(r, 1, grad_rho, e0);
    double E0_1 = e0;
    double E0_prime_1 = grad_rho;

    //if(E0_prime_1 )
    double max_g;
    rho = initial_guess(r, E0_0, E0_1, E0_prime_0, E0_prime_1, max_g);
    //cout << "rho ig: " << rho << endl;

    E_0_co(r, rho + 0.0000001, grad_rho, e0);
    double E0_prime_guess_plus = grad_rho;

    E_0_co(r, rho, grad_rho, e0);
    double E0_prime_guess = grad_rho;

    // si e0'(rho)-r s positiva del punt fins a 1, si s neg de 0 al punt
    /*
    double g_rho = grad_rho-r;

    if(g_rho <= 0){
        cout << "cas1" << endl;
        E_0_co(r, rho, grad_rho, e0);
        E0_prime_1 = grad_rho;
        //E0_second_prime_0 is at rho=0
    }
    else if(g_rho >= 0){
        cout << "cas2" << endl;
        E_0_co(r, rho, grad_rho, grad_2_rho,e0, my_n-1, hweights, multhweights, roots);
        E0_prime_0 = grad_rho;
        E0_second_prime_0 = grad_2_rho;
    }
    */

    //cout << "grad_2_guess: " << grad_2_guess << endl;

    //double L = ();

    double grad_2_guess = ((E0_prime_guess_plus - E0_prime_guess) / (0.0000001));
    double L = (-grad_2_guess);
    learning_rate = 1 / L;
    k = 1; // L/(-grad_2_guess);

    cout << "k: " << k << endl;
    double kaux = ((sqrt(k) - 1) / (sqrt(k) + 1));
    cout << "lr: " << learning_rate << endl;


    for (int i = 0; i < num_iterations; ++i) {
        cout << "lr: " << fixed << setprecision(16) << learning_rate << endl;
        /*
        my_n = ceil(low + increment*i);

        if(my_n != prev_n){
            //free(&hweights); free(&roots); free(&multhweights);
            hweights = all_hweights[my_n];
            roots = all_roots[my_n];
            multhweights = all_multhweights[my_n];
        }

        prev_n = my_n;
         */

        auto start_inner2 = std::chrono::high_resolution_clock::now();
        // gradient_e0_co(r, rho, grad_r, grad_rho, my_n-1, hweights, multhweights, roots);

        // cout << "gr: " << grad_rho << endl;
        //cout << "rho: " << rho << endl;

        //rho = rhos[i];
        E_0_co(0.5, rho, grad_rho, e0);
        grad_rho -= R;
        //cout << "gr_new: " << grad_rho << endl;

        //cout << "rho: " << rho << endl;

        //rho = rhos[i];
        //gradient_e0_co(0, rho, grad_r, grad_rho, my_n-1, hweights, multhweights, roots);

        //cout << "gr_old: " << grad_rho << endl;
        //cout << "rho: " << rho << endl;

        auto stop_inner2 = std::chrono::high_resolution_clock::now();
        auto duration_inner2 = std::chrono::duration_cast<std::chrono::microseconds>(stop_inner2 - start_inner2);
        inner_times.push_back(duration_inner2);


        grad_rho = -grad_rho;
        grad_r = -grad_r;


        if (updateR) { NAG_update(r, auxr, nextr, nextauxr, learning_rate, grad_r, kaux); }
        else { r = 0; }
        //else r = 0.000001;
        //cout << "lr:" << learning_rate << endl;

        NAG_update(rho, auxrho, nextrho, nextauxrho, learning_rate, grad_rho, kaux);
        //if (rho <= 0) rho = 0.00000001; else if (rho >= 1) rho = 0.99999999;
        //rho += grad_rho;
        if (rho <= -1) rho = -1;
        if (rho >= 2) rho = 2;

        /*
        //if(!updateR || grad_r <= error && grad_r >= -error){
            if(rho == 0.00000001 || rho == 0.99999999 || grad_rho <= error && grad_rho >= -error){
                //cout << rho << " " << grad_rho << " " << grad_r << " " << endl;
                //cout << i << endl;
                return e0 - rho*R;
            }
        //}
        */
        /*if(DEBUG) */

        if (grad_rho <= error && grad_rho >= -error) {
            auto stop_XX = std::chrono::high_resolution_clock::now();
            auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
            //NAG_co_times.push_back(duration_XX - sum_(inner_times));
            cout << "NAG duration: " << duration_XX.count() << endl;
            return e0 - rho * R;
        }
        cout << fixed << setprecision(17) << i << " " << rho << " " << e0 << " " << e0 - rho * R << " " << grad_rho
             << endl;
    }
    //cout << rho << " " << grad_rho << " " << grad_r << " " << endl;
    //cout << num_iterations << endl;

    auto stop_XX = std::chrono::high_resolution_clock::now();
    auto duration_XX = std::chrono::duration_cast<std::chrono::microseconds>(stop_XX - start_XX);
    //NAG_co_times.push_back(duration_XX - sum_(inner_times));
    cout << "NAG duration: " << duration_XX.count() << endl;
    return e0 - rho * R;
}

double NAG_iid(double &r, double &rho, double learning_rate, int num_iterations, int n, double k) {
    auto start_NAG_iid = std::chrono::high_resolution_clock::now();
    //cout << endl << "cooking" << endl;
    double out = NAG_co(r, rho, learning_rate, num_iterations, n, k, false);

    auto stop_NAG_iid = std::chrono::high_resolution_clock::now();
    auto duration_NAG_iid = std::chrono::duration_cast<std::chrono::microseconds>(stop_NAG_iid - start_NAG_iid);
    NAG_iid_times.push_back(chrono::microseconds(0));

    return out;
}

double NAG_cc(double &r, double &rho, double learning_rate, int num_iterations, int n, double k) {
    auto start_NAG_cc = std::chrono::high_resolution_clock::now();

    double out = NAG_co(r, rho, learning_rate, num_iterations, n, k, true);

    auto stop_NAG_cc = std::chrono::high_resolution_clock::now();
    auto duration_NAG_cc = std::chrono::duration_cast<std::chrono::microseconds>(stop_NAG_cc - start_NAG_cc);
    NAG_cc_times.push_back(duration_NAG_cc);

    return out;
}


#endif //TFG_FUNCTIONS_H